---
import Base from '../layouts/Base.astro';
import Background from '../components/Background.svelte';
import { apiUrl, forwardedApiHeaders } from '../utils/api';

type ContentSection = {
  heading: string;
  body: string;
};

const fallbackContent = {
  title: 'About',
  sections: [
    {
      heading: 'Transmission',
      body:
        "VOIDWIRE is a daily dispatch from the celestial wire -- an automated reading of planetary positions, lunar phases, and astronomical transits, rendered into prose by machine intelligence and delivered each day at the threshold between night and morning.\n\nEach reading is generated from precise ephemeris calculations, interpreting the geometry of the solar system as it appears from Earth. The positions are real. The aspects are exact. The language is synthetic.",
    },
    {
      heading: 'Philosophy',
      body:
        'This project sits at the intersection of ancient pattern-recognition and modern computation. The sky has been read for millennia. VOIDWIRE simply automates the observation, stripping away human bias while preserving the structure of the interpretive tradition.\n\nNo claims are made about causality or influence. The transmissions are literary artifacts shaped by astronomical data -- nothing more, nothing less.',
    },
    {
      heading: 'Typography & Design',
      body:
        "The site is set in EB Garamond, a revival of Claude Garamont's sixteenth-century type. The choice is deliberate: a typeface designed for sustained reading, rooted in the same era that produced the first printed ephemerides and astronomical tables.\n\nThe void-black background eliminates distraction. Text is rendered in muted parchment tones -- warm enough to read comfortably, dim enough to feel like reading by candlelight. The design prioritizes the word above all else.",
    },
    {
      heading: 'Colophon',
      body:
        'Built with Astro and Svelte. Ephemeris calculations via Swiss Ephemeris. Served from the void.\n\nThe source is the sky. The medium is the wire. The rest is noise.',
    },
  ] as ContentSection[],
};

let contentTitle = fallbackContent.title;
let contentSections = fallbackContent.sections;
const apiHeaders = forwardedApiHeaders(Astro.clientAddress);

try {
  const res = await fetch(apiUrl('/v1/content/about'), { headers: apiHeaders });
  if (res.ok) {
    const data = await res.json();
    const title = typeof data?.title === 'string' ? data.title.trim() : '';
    const sections = Array.isArray(data?.sections)
      ? data.sections
          .map((raw: unknown): ContentSection | null => {
            if (!raw || typeof raw !== 'object') return null;
            const section = raw as Record<string, unknown>;
            const heading = String(section.heading ?? '').trim();
            const body = String(section.body ?? '').trim();
            if (!heading && !body) return null;
            return { heading, body };
          })
          .filter((section: ContentSection | null): section is ContentSection => section !== null)
      : [];

    if (title) contentTitle = title;
    if (sections.length > 0) contentSections = sections;
  }
} catch {
  // Keep fallback content when API is unavailable.
}

function escapeHtml(text: string) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function refineTypography(text: string) {
  return escapeHtml(text)
    .replace(/\.\.\./g, '&hellip;')
    .replace(/--/g, '&mdash;')
    .replace(/(^|[-\s(\[<{])"/g, '$1&ldquo;')
    .replace(/"/g, '&rdquo;')
    .replace(/(^|[-\s(\[<{])'/g, '$1&lsquo;')
    .replace(/'/g, '&rsquo;');
}

function toParagraphsHtml(body: string): string {
  return body
    .split(/\n\n+/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((p) => `<p>${refineTypography(p)}</p>`)
    .join('\n');
}
---

<Base title={contentTitle}>
  <Background />

  <header class="site-header">
    <h1 class="site-title"><a href="/">VOIDWIRE</a></h1>
    <nav class="site-nav">
      <a href="/archive">Archive</a>
      <a href="/events">Events</a>
      <a href="/about">About</a>
    </nav>
  </header>

  <main class="colophon">
    {contentSections.map((section, i) => (
      <section class:list={['about-section', { 'first-section': i === 0 }]}>
        {section.heading && <h2>{section.heading}</h2>}
        <div class="about-body" set:html={toParagraphsHtml(section.body)} />
      </section>
    ))}
  </main>
</Base>

<style>
  .about-section + .about-section {
    margin-top: 2rem;
  }

  .first-section .about-body :global(p:first-child::first-letter) {
    font-size: 3.5rem;
    float: left;
    line-height: 0.8;
    padding-right: 0.15rem;
    margin-top: 0.15rem;
    color: var(--accent);
  }
</style>
