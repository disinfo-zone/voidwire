---
import Base from '../layouts/Base.astro';
import Background from '../components/Background.svelte';
import BirthDataForm from '../components/BirthDataForm.svelte';
import SubscriptionManager from '../components/SubscriptionManager.svelte';
---

<Base title="Dashboard">
  <Background />

  <header class="site-header">
    <div class="site-title"><a href="/">VOIDWIRE</a></div>
    <nav class="site-nav">
      <a href="/archive">Archive</a>
      <a href="/events">Events</a>
      <a href="/about">About</a>
    </nav>
  </header>

  <main>
    <div id="dashboard-content" style="display: none;">
      <div class="dashboard-container">
        <div class="dashboard-header">
          <h1 class="page-title">Your Dashboard</h1>
          <div class="view-toggle">
            <button id="view-reading-btn" class="view-toggle-button active">Reading</button>
            <button id="view-settings-btn" class="view-toggle-button">Settings</button>
          </div>
        </div>

        <div id="onboarding-message" class="onboarding-message" style="display: none;"></div>

        <section id="reading-section" class="reading-section" style="display: none;">
          <div id="reading-status" class="reading-status" style="display: none;"></div>
          <div id="reading-content" class="reading-content">
            <div class="loading">Tuning into the wire\u2026</div>
          </div>
          <div id="reading-actions" class="reading-actions"></div>
        </section>

        <section id="settings-section" class="settings-section" style="display: none;">
          <div class="section-label">Natal Chart</div>
          <div id="chart-status" class="reading-status">Your chart is loading.</div>
          <div class="chart-wheel-wrap">
            <canvas id="chart-wheel-canvas"></canvas>
          </div>
          <div id="chart-content" class="chart-content"></div>
          <div class="chart-actions">
            <button id="export-chart-text-btn" class="action-button" style="display: none;">Copy Chart</button>
            <button id="export-chart-image-btn" class="action-button" style="display: none;">Export Chart Image</button>
          </div>

          <div class="section-label">Account</div>
          <div id="user-info" class="user-info"></div>

          <div class="section-label">Birth Data</div>
          <div id="profile-status" class="profile-status"></div>
          <button id="toggle-birth-form" class="edit-button" style="display: none;">Edit Birth Data</button>
          <div id="birth-form-wrapper" style="display: none;">
            <BirthDataForm client:visible onSave={() => window.location.reload()} />
          </div>

          <div class="section-label">Subscription</div>
          <SubscriptionManager client:visible />

          <div class="section-label">Data Export</div>
          <div class="chart-actions">
            <button id="export-account-btn" class="action-button">Export Account JSON</button>
          </div>
        </section>

        <div class="logout-wrapper">
          <button id="logout-button" class="logout-button">Logout</button>
        </div>
      </div>
    </div>
  </main>
</Base>

<script>
  import { clearToken, authFetch } from '../utils/auth';

  type DashboardUser = {
    id: string;
    email: string;
    email_verified: boolean;
    display_name: string | null;
    has_profile: boolean;
    tier: 'free' | 'pro';
    is_admin_user?: boolean;
    is_test_user?: boolean;
    can_manage_readings?: boolean;
    created_at: string | null;
  };

  type ReadingPayload = {
    tier: 'free' | 'pro';
    title: string;
    body: string;
    sections: { heading: string; body: string }[];
    word_count: number;
    date_context: string;
    coverage_label?: string;
    coverage_start?: string;
    coverage_end?: string;
    template_version?: string;
  };

  const content = document.getElementById('dashboard-content');
  if (content) content.style.display = 'block';

  let hasProfile = false;
  let canManageReadings = false;
  let activeJobId: string | null = null;
  let readingPollTimer: number | null = null;
  let readingPollStartedAt = 0;
  let cachedChart: Record<string, unknown> | null = null;
  let chartBrandDomain = 'voidwire.app';
  const SIGN_ORDER = [
    'Aries',
    'Taurus',
    'Gemini',
    'Cancer',
    'Leo',
    'Virgo',
    'Libra',
    'Scorpio',
    'Sagittarius',
    'Capricorn',
    'Aquarius',
    'Pisces',
  ];
  const SIGN_COLORS: Record<string, string> = {
    Aries: '#ff8b7b',
    Taurus: '#e3c470',
    Gemini: '#f1ea86',
    Cancer: '#9fd2ff',
    Leo: '#ffcc6a',
    Virgo: '#bce68f',
    Libra: '#b9a3ff',
    Scorpio: '#df8fff',
    Sagittarius: '#ffad80',
    Capricorn: '#8ec5b8',
    Aquarius: '#90d0ff',
    Pisces: '#a0a6ff',
  };
  const VS15 = '\uFE0E';
  const PLANET_GLYPHS: Record<string, string> = {
    Sun: `\u2609${VS15}`, Moon: `\u263D${VS15}`, Mercury: `\u263F${VS15}`, Venus: `\u2640${VS15}`,
    Mars: `\u2642${VS15}`, Jupiter: `\u2643${VS15}`, Saturn: `\u2644${VS15}`, Uranus: `\u2645${VS15}`,
    Neptune: `\u2646${VS15}`, Pluto: `\u2647${VS15}`, Chiron: `\u26B7${VS15}`, 'North Node': `\u260A${VS15}`,
  };
  const SIGN_GLYPHS: Record<string, string> = {
    Aries: `\u2648${VS15}`, Taurus: `\u2649${VS15}`, Gemini: `\u264A${VS15}`, Cancer: `\u264B${VS15}`,
    Leo: `\u264C${VS15}`, Virgo: `\u264D${VS15}`, Libra: `\u264E${VS15}`, Scorpio: `\u264F${VS15}`,
    Sagittarius: `\u2650${VS15}`, Capricorn: `\u2651${VS15}`, Aquarius: `\u2652${VS15}`, Pisces: `\u2653${VS15}`,
  };
  const CHART_ASPECT_COLORS: Record<string, string> = {
    conjunction: '#d6af72', opposition: '#e07060', trine: '#5888c8',
    square: '#c04040', sextile: '#50a868',
  };
  const ASPECT_GLYPHS: Record<string, string> = {
    conjunction: `\u260C${VS15}`, opposition: `\u260D${VS15}`, trine: '\u25B3',
    square: '\u25A1', sextile: `\u26B9${VS15}`,
  };
  const ELEMENT_MAP: Record<string, string> = {
    Aries: 'Fire', Taurus: 'Earth', Gemini: 'Air', Cancer: 'Water',
    Leo: 'Fire', Virgo: 'Earth', Libra: 'Air', Scorpio: 'Water',
    Sagittarius: 'Fire', Capricorn: 'Earth', Aquarius: 'Air', Pisces: 'Water',
  };
  const MODALITY_MAP: Record<string, string> = {
    Aries: 'Cardinal', Taurus: 'Fixed', Gemini: 'Mutable', Cancer: 'Cardinal',
    Leo: 'Fixed', Virgo: 'Mutable', Libra: 'Cardinal', Scorpio: 'Fixed',
    Sagittarius: 'Mutable', Capricorn: 'Cardinal', Aquarius: 'Fixed', Pisces: 'Mutable',
  };

  function escapeHtml(value: unknown): string {
    return String(value ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function paragraphsToHtml(value: unknown): string {
    return String(value ?? '')
      .split(/\n\n+/)
      .map((p) => p.trim())
      .filter(Boolean)
      .map((p) => `<p>${escapeHtml(p)}</p>`)
      .join('');
  }

  function sectionToHtml(section: any): string {
    const heading = escapeHtml(section?.heading ?? '');
    const body = paragraphsToHtml(section?.body ?? '');
    return `<div class="section"><h3 class="section-heading">${heading}</h3>${body}</div>`;
  }

  function normalizeSign(sign: unknown): string {
    const raw = String(sign || '').trim().toLowerCase();
    return SIGN_ORDER.find((entry) => entry.toLowerCase() === raw) || String(sign || '').trim();
  }

  function zodiacDegrees(sign: unknown, degree: unknown): number {
    const normalized = normalizeSign(sign);
    const signIndex = SIGN_ORDER.findIndex((entry) => entry === normalized);
    const safeDegree = Number.isFinite(Number(degree)) ? Number(degree) : 0;
    const boundedDegree = ((safeDegree % 30) + 30) % 30;
    if (signIndex < 0) return boundedDegree;
    return signIndex * 30 + boundedDegree;
  }

  function bodyAbbreviation(body: unknown): string {
    const label = String(body || '').trim();
    if (!label) return '?';
    if (label.length <= 3) return label.toUpperCase();
    if (label.toLowerCase() === 'north node') return 'NN';
    if (label.toLowerCase() === 'south node') return 'SN';
    return label.slice(0, 2).toUpperCase();
  }

  /** Convert raw body names (snake_case, lowercase) to display-ready labels. */
  function displayBody(raw: unknown): string {
    const s = String(raw || '').trim();
    if (!s) return '';
    // Replace underscores/hyphens with spaces, then Title Case each word
    return s.replace(/[_-]/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
  }

  function siteDomainLabel(value: unknown): string {
    const raw = String(value || '').trim();
    if (!raw) return 'voidwire.app';

    const withoutProtocol = raw.replace(/^https?:\/\//i, '');
    const withoutQuery = withoutProtocol.split(/[?#]/)[0] || withoutProtocol;
    try {
      const parsed = new URL(raw.startsWith('http://') || raw.startsWith('https://') ? raw : `https://${raw}`);
      const path = parsed.pathname && parsed.pathname !== '/' ? parsed.pathname.replace(/\/+$/, '') : '';
      return `${parsed.host}${path}` || withoutQuery;
    } catch {
      return withoutQuery.replace(/\/+$/, '') || 'voidwire.app';
    }
  }

  function setReadingActionVisibility() {
    const readingActions = document.getElementById('reading-actions') as HTMLElement | null;
    if (!readingActions) return;
    if (!canManageReadings) {
      readingActions.innerHTML = '';
      readingActions.classList.remove('visible');
      return;
    }
    if (!readingActions.querySelector('#refresh-reading-btn')) {
      readingActions.innerHTML =
        '<button id="refresh-reading-btn" class="action-button">Refresh</button>' +
        '<button id="generate-reading-btn" class="action-button">Generate Latest</button>';
      document.getElementById('refresh-reading-btn')?.addEventListener('click', () => {
        if (!canManageReadings) return;
        void startReadingFlow();
      });
      document.getElementById('generate-reading-btn')?.addEventListener('click', async () => {
        if (!hasProfile || !canManageReadings) return;
        stopReadingPolling();
        activeJobId = null;
        updateReadingStatus('Requesting a fresh transmission\u2026');
        renderReadingMessage('Clearing the channel for a new transmission\u2026');
        try {
          activeJobId = await enqueueOrReuseReadingJob({ forceRefresh: true, reuseActive: false });
          readingPollStartedAt = Date.now();
          await pollReadingJob();
          if (activeJobId) {
            readingPollTimer = window.setInterval(() => {
              void pollReadingJob();
            }, 4000);
          }
        } catch (err) {
          renderReadingMessage(err instanceof Error ? err.message : 'The reading could not be channeled');
          updateReadingStatus('The signal was lost in the void.');
        }
      });
    }
    readingActions.classList.add('visible');
  }

  async function loadBrandDomain() {
    try {
      const res = await fetch('/v1/site/config', { credentials: 'include' });
      if (!res.ok) return;
      const cfg = await res.json();
      chartBrandDomain = siteDomainLabel(cfg?.site_url);
    } catch {
      chartBrandDomain = chartBrandDomain || 'voidwire.app';
    }
  }

  function setView(view: 'reading' | 'settings') {
    const readingSection = document.getElementById('reading-section');
    const settingsSection = document.getElementById('settings-section');
    const readingBtn = document.getElementById('view-reading-btn');
    const settingsBtn = document.getElementById('view-settings-btn');
    if (readingSection) readingSection.style.display = view === 'reading' ? 'block' : 'none';
    if (settingsSection) settingsSection.style.display = view === 'settings' ? 'block' : 'none';
    readingBtn?.classList.toggle('active', view === 'reading');
    settingsBtn?.classList.toggle('active', view === 'settings');
  }

  function updateReadingStatus(message: string) {
    const status = document.getElementById('reading-status');
    if (status) {
      status.textContent = message;
      (status as HTMLElement).style.display = message ? 'block' : 'none';
    }
  }

  function stopReadingPolling() {
    if (readingPollTimer !== null) {
      window.clearInterval(readingPollTimer);
      readingPollTimer = null;
    }
    activeJobId = null;
  }

  function downloadBlob(filename: string, blob: Blob) {
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = filename;
    anchor.click();
    URL.revokeObjectURL(url);
  }

  function downloadJson(filename: string, payload: unknown) {
    downloadBlob(filename, new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }));
  }

  function downloadText(filename: string, text: string) {
    downloadBlob(filename, new Blob([text], { type: 'text/plain;charset=utf-8' }));
  }

  function renderReading(reading: ReadingPayload) {
    const readingContent = document.getElementById('reading-content');
    if (!readingContent) return;

    const tierLabel = reading.tier === 'pro' ? 'Daily Pro Reading' : 'Weekly Reading';
    const bodyHtml = paragraphsToHtml(reading.body);
    const sections = Array.isArray(reading.sections) ? reading.sections : [];
    const sectionsHtml = sections.length > 0 ? sections.map((s) => sectionToHtml(s)).join('') : '';
    const safeTitle = escapeHtml(reading.title);
    const safeDateContext = escapeHtml(reading.date_context);
    const safeCoverage = escapeHtml(reading.coverage_label || '');
    const safeWordCount = Number(reading.word_count) || 0;
    const safeTemplate = reading.template_version ? escapeHtml(reading.template_version) : '';
    const showTemplate = canManageReadings && !!safeTemplate;

    readingContent.innerHTML = `
      <div class="reading-tier-badge">${escapeHtml(tierLabel)}</div>
      <h2 class="reading-title">${safeTitle}</h2>
      <div class="reading-meta">${safeDateContext}${safeCoverage ? ` · ${safeCoverage}` : ''} · ${safeWordCount} words</div>
      <div class="reading-body">${bodyHtml}</div>
      ${sectionsHtml}
      ${showTemplate ? `<div class="reading-template">Template: ${safeTemplate}</div>` : ''}
    `;
    setReadingActionVisibility();
    updateReadingStatus('');
  }

  function renderReadingMessage(message: string) {
    const readingContent = document.getElementById('reading-content');
    if (!readingContent) return;
    readingContent.innerHTML = `<p class="muted">${escapeHtml(message)}</p>`;
  }

  async function fetchCurrentReading(): Promise<ReadingPayload | null> {
    const readingRes = await authFetch('/v1/user/readings/personal/current');
    if (readingRes.status === 404) return null;
    if (readingRes.status === 503) {
      renderReadingMessage('Personal reading LLM slot is not configured yet. Ask your admin to configure personal_free/personal_pro.');
      updateReadingStatus('Reading generation unavailable.');
      throw new Error('Reading generation unavailable');
    }
    if (!readingRes.ok) {
      const data = await readingRes.json().catch(() => ({}));
      throw new Error(data?.detail || 'Could not load reading');
    }
    return await readingRes.json();
  }

  async function enqueueOrReuseReadingJob(options?: { forceRefresh?: boolean; reuseActive?: boolean }) {
    const forceRefresh = Boolean(options?.forceRefresh);
    const reuseActive = options?.reuseActive !== false;
    if (reuseActive) {
      const jobsRes = await authFetch('/v1/user/readings/personal/jobs?limit=20');
      if (jobsRes.ok) {
        const jobs = await jobsRes.json();
        if (Array.isArray(jobs)) {
          const today = new Date().toISOString().slice(0, 10);
          const active = jobs.find((job: any) => {
            const jobForce = Boolean(job?.payload?.force_refresh);
            return (
              (job.status === 'queued' || job.status === 'running') &&
              String(job?.payload?.target_date || '') === today &&
              jobForce === forceRefresh
            );
          });
          if (active?.id) return String(active.id);
        }
      }
    }
    const createRes = await authFetch('/v1/user/readings/personal/jobs', {
      method: 'POST',
      body: JSON.stringify({ tier: 'auto', force_refresh: forceRefresh }),
    });
    if (!createRes.ok) {
      const data = await createRes.json().catch(() => ({}));
      throw new Error(data?.detail || 'Failed to start reading generation');
    }
    const job = await createRes.json();
    if (!job?.id) throw new Error('Reading job was not created');
    return String(job.id);
  }

  async function pollReadingJob() {
    if (!activeJobId) return;
    const elapsed = Math.max(Math.round((Date.now() - readingPollStartedAt) / 1000), 1);
    const statusRes = await authFetch(`/v1/user/readings/personal/jobs/${activeJobId}`);
    if (!statusRes.ok) {
      updateReadingStatus('Lost contact with the signal.');
      return;
    }
    const job = await statusRes.json();
    const jobStatus = String(job?.status || 'queued');
    if (jobStatus === 'queued' || jobStatus === 'running') {
      updateReadingStatus(`Channeling the celestial signal\u2026 ${elapsed}s elapsed. Deep readings may take a few minutes.`);
      return;
    }
    if (jobStatus === 'failed') {
      stopReadingPolling();
      const message = String(job?.error_message || 'The reading could not be channeled');
      renderReadingMessage(message);
      updateReadingStatus('The signal was lost in the void.');
      return;
    }
    if (jobStatus === 'completed') {
      stopReadingPolling();
      const reading = await fetchCurrentReading();
      if (reading) {
        renderReading(reading);
      } else {
        renderReadingMessage('The transmission has arrived but has not yet materialized. Refresh in a moment.');
        updateReadingStatus('Transmission received. Awaiting materialization.');
      }
    }
  }

  async function startReadingFlow() {
    if (!hasProfile) return;
    updateReadingStatus('Scanning the celestial wire\u2026');
    try {
      const reading = await fetchCurrentReading();
      if (reading) {
        renderReading(reading);
        stopReadingPolling();
        return;
      }

      const readingContent = document.getElementById('reading-content');
      if (readingContent) {
        readingContent.innerHTML = '<div class="loading">Attuning to your natal frequency\u2026</div>';
      }
      stopReadingPolling();
      activeJobId = await enqueueOrReuseReadingJob();
      readingPollStartedAt = Date.now();
      updateReadingStatus('Awaiting celestial alignment\u2026');
      await pollReadingJob();
      if (activeJobId) {
        readingPollTimer = window.setInterval(() => {
          void pollReadingJob();
        }, 4000);
      }
    } catch (err) {
      renderReadingMessage(err instanceof Error ? err.message : 'Could not load reading');
      updateReadingStatus('Could not load reading.');
    }
  }

  async function loadNatalChart() {
    const chartStatus = document.getElementById('chart-status');
    const chartContent = document.getElementById('chart-content');
    const exportTextButton = document.getElementById('export-chart-text-btn') as HTMLButtonElement | null;
    const exportImageButton = document.getElementById('export-chart-image-btn') as HTMLButtonElement | null;
    if (chartStatus) chartStatus.textContent = 'Loading natal chart...';
    try {
      const res = await authFetch('/v1/user/profile/natal-chart');
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data?.detail || 'Could not load chart');
      }
      const chart = await res.json();
      cachedChart = chart;
      const positions = Array.isArray(chart?.positions) ? chart.positions : [];
      const angles = Array.isArray(chart?.angles) ? chart.angles : [];
      const houseSystem = String(chart?.house_system || 'Placidus');

      // --- Render chart wheel on canvas ---
      const wheelCanvas = document.getElementById('chart-wheel-canvas') as HTMLCanvasElement | null;
      if (wheelCanvas) {
        const container = wheelCanvas.parentElement;
        const displaySize = Math.min(container?.clientWidth || 500, 500);
        const dpr = window.devicePixelRatio || 1;
        wheelCanvas.width = displaySize * dpr;
        wheelCanvas.height = displaySize * dpr;
        wheelCanvas.style.width = `${displaySize}px`;
        wheelCanvas.style.height = `${displaySize}px`;
        const wctx = wheelCanvas.getContext('2d');
        if (wctx) {
          // Dark background fill
          const bg = wctx.createRadialGradient(
            wheelCanvas.width / 2, wheelCanvas.height / 2, 0,
            wheelCanvas.width / 2, wheelCanvas.height / 2, wheelCanvas.width / 2,
          );
          bg.addColorStop(0, '#0a1228');
          bg.addColorStop(1, '#080510');
          wctx.fillStyle = bg;
          wctx.fillRect(0, 0, wheelCanvas.width, wheelCanvas.height);
          drawChartWheel(wctx, chart, displaySize * dpr, (displaySize * dpr) / 2, (displaySize * dpr) / 2);
        }
      }

      // --- Build designed chart content ---
      if (chartContent) {
        const sun = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'sun');
        const moon = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'moon');
        const asc = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');
        const mc = angles.find((a: any) => {
          const n = String(a?.name || '').toLowerCase();
          return n === 'midheaven' || n === 'mc';
        });

        // Core signature hero row
        const heroItems = [sun, moon, asc].filter(Boolean).map((item: any) => {
          const isAngle = !!item?.name;
          const rawBody = isAngle ? 'ASC' : String(item?.body || '');
          const body = isAngle ? 'ASC' : displayBody(rawBody);
          const glyph = isAngle ? '' : (PLANET_GLYPHS[body] || PLANET_GLYPHS[rawBody] || '');
          const sign = normalizeSign(item?.sign);
          const signGlyph = SIGN_GLYPHS[sign] || '';
          const color = SIGN_COLORS[sign] || '#d6af72';
          const deg = Number(item?.degree || 0).toFixed(1);
          return `<div class="chart-hero-item">
            <span class="chart-hero-glyph" style="color: ${color}">${escapeHtml(glyph || (isAngle ? 'ASC' : ''))}</span>
            <span class="chart-hero-label">${escapeHtml(body)}</span>
            <span class="chart-hero-detail">${escapeHtml(deg)}\u00B0 ${escapeHtml(signGlyph)} ${escapeHtml(sign)}</span>
          </div>`;
        }).join('');

        // Placements grid
        const sortedPos = [...positions].sort(
          (a: any, b: any) => zodiacDegrees(a?.sign, a?.degree) - zodiacDegrees(b?.sign, b?.degree),
        );
        const placementItems = sortedPos.map((pos: any) => {
          const rawBody = String(pos?.body || '');
          const body = displayBody(rawBody);
          const glyph = PLANET_GLYPHS[body] || PLANET_GLYPHS[rawBody] || '';
          const sign = normalizeSign(pos?.sign);
          const signGlyph = SIGN_GLYPHS[sign] || '';
          const color = SIGN_COLORS[sign] || '#d6af72';
          const deg = Number(pos?.degree || 0).toFixed(1);
          const house = pos?.house ? `H${pos.house}` : '';
          const retro = Boolean(pos?.retrograde);
          return `<div class="chart-placement">
            <span class="chart-placement-glyph" style="color: ${color}">${escapeHtml(glyph)}</span>
            <span class="chart-placement-name">${escapeHtml(body)}${retro ? ' <span class="chart-retro">\u211E</span>' : ''}</span>
            <span class="chart-placement-detail">${escapeHtml(deg)}\u00B0 ${escapeHtml(signGlyph)} ${escapeHtml(sign)}${house ? ` \u00B7 ${escapeHtml(house)}` : ''}</span>
          </div>`;
        }).join('');

        // Footer line
        const footerParts: string[] = [];
        if (asc) footerParts.push(`Asc ${Number(asc.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(asc.sign)}`);
        if (mc) footerParts.push(`MC ${Number(mc.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(mc.sign)}`);
        footerParts.push(houseSystem);

        chartContent.innerHTML = `
          <div class="chart-hero">${heroItems}</div>
          <div class="chart-placements">${placementItems}</div>
          <div class="chart-detail-footer">${escapeHtml(footerParts.join('  \u00B7  '))}</div>
        `;
      }
      if (chartStatus) chartStatus.style.display = 'none';
      if (exportTextButton) exportTextButton.style.display = 'inline-flex';
      if (exportImageButton) exportImageButton.style.display = 'inline-flex';
    } catch (err) {
      if (exportTextButton) exportTextButton.style.display = 'none';
      if (exportImageButton) exportImageButton.style.display = 'none';
      if (chartStatus) {
        chartStatus.style.display = 'block';
        chartStatus.textContent = err instanceof Error ? err.message : 'Could not load natal chart';
      }
    }
  }

  function natalChartText(chart: Record<string, unknown>): string {
    const data = chart as any;
    const positions = Array.isArray(data.positions) ? (data.positions as any[]) : [];
    const angles = Array.isArray(data.angles) ? (data.angles as any[]) : [];
    const lines: string[] = [];
    lines.push('VOIDWIRE Natal Chart Export');
    lines.push(`Generated: ${new Date().toISOString()}`);
    lines.push('');
    lines.push('Placements:');
    for (const pos of positions) {
      const body = String(pos?.body || '');
      const degree = Number(pos?.degree || 0).toFixed(2);
      const sign = String(pos?.sign || '');
      const house = pos?.house ? `House ${pos.house}` : 'No house';
      lines.push(`- ${body}: ${degree}° ${sign} (${house})`);
    }
    if (angles.length > 0) {
      lines.push('');
      lines.push('Angles:');
      for (const angle of angles) {
        const name = String(angle?.name || '');
        const degree = Number(angle?.degree || 0).toFixed(2);
        const sign = String(angle?.sign || '');
        lines.push(`- ${name}: ${degree}° ${sign}`);
      }
    }
    return lines.join('\n');
  }

  async function ensureFontsLoaded() {
    await Promise.all([
      document.fonts.load('400 48px "EB Garamond"'),
      document.fonts.load('600 48px "EB Garamond"'),
      document.fonts.load('500 48px "Inter"'),
      document.fonts.load('600 48px "Inter"'),
      document.fonts.load('400 48px "JetBrains Mono"'),
    ]);
  }

  function drawChartWheel(ctx: CanvasRenderingContext2D, chart: any, size: number, cx: number, cy: number) {
    const scale = size / 1100;
    const positions = Array.isArray(chart.positions) ? (chart.positions as any[]) : [];
    const angles = Array.isArray(chart.angles) ? (chart.angles as any[]) : [];
    const aspects = Array.isArray(chart.aspects) ? (chart.aspects as any[]) : [];
    const houseCusps = Array.isArray(chart.house_cusps) ? (chart.house_cusps as number[]) : [];

    const R_OUTER = 460, R_SIGN_INNER = 390, R_INNER = 255;
    const BRASS = '#d6af72';

    const ascAngle = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');
    const ascLong = ascAngle ? Number(ascAngle.longitude || 0) : 0;

    function longToAngle(longitude: number): number {
      return Math.PI - ((longitude - ascLong) * Math.PI) / 180;
    }

    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);

    // --- Layer 4: Sacred geometry ---
    ctx.save();
    ctx.strokeStyle = 'rgba(214, 175, 114, 0.055)';
    ctx.lineWidth = 1;
    for (let k = 0; k < 2; k++) {
      ctx.beginPath();
      for (let i = 0; i < 3; i++) {
        const a = ((i * 120 + k * 60) * Math.PI) / 180;
        if (i === 0) ctx.moveTo(Math.cos(a) * R_INNER * 0.9, Math.sin(a) * R_INNER * 0.9);
        else ctx.lineTo(Math.cos(a) * R_INNER * 0.9, Math.sin(a) * R_INNER * 0.9);
      }
      ctx.closePath();
      ctx.stroke();
    }
    const phi = 1.618033988749;
    for (let i = 1; i <= 4; i++) {
      const r = R_INNER * 0.15 * Math.pow(phi, i);
      if (r < R_OUTER) { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); }
    }
    for (let deg = 0; deg < 360; deg += 15) {
      const a = (deg * Math.PI) / 180;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a) * R_INNER * 0.3, Math.sin(a) * R_INNER * 0.3);
      ctx.lineTo(Math.cos(a) * R_INNER * 0.85, Math.sin(a) * R_INNER * 0.85);
      ctx.stroke();
    }
    ctx.restore();

    // --- Layer 5: Wheel structure ---
    ctx.save();

    ctx.strokeStyle = 'rgba(214, 175, 114, 0.5)';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(0, 0, R_OUTER, 0, Math.PI * 2); ctx.stroke();

    ctx.strokeStyle = 'rgba(214, 175, 114, 0.35)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(0, 0, R_SIGN_INNER, 0, Math.PI * 2); ctx.stroke();

    ctx.strokeStyle = 'rgba(214, 175, 114, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0, 0, R_INNER, 0, Math.PI * 2); ctx.stroke();

    for (let i = 0; i < 12; i++) {
      const signLongStart = i * 30;
      const startA = longToAngle(signLongStart);
      const endA = longToAngle(signLongStart + 30);
      const sign = SIGN_ORDER[i];
      const signColor = SIGN_COLORS[sign] || '#9aa6c0';

      ctx.beginPath();
      ctx.arc(0, 0, R_OUTER, startA, endA, true);
      ctx.arc(0, 0, R_SIGN_INNER, endA, startA, false);
      ctx.closePath();
      ctx.fillStyle = `${signColor}15`;
      ctx.fill();

      ctx.strokeStyle = 'rgba(214, 175, 114, 0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(startA) * R_SIGN_INNER, Math.sin(startA) * R_SIGN_INNER);
      ctx.lineTo(Math.cos(startA) * R_OUTER, Math.sin(startA) * R_OUTER);
      ctx.stroke();

      const midA = longToAngle(signLongStart + 15);
      const glyphR = (R_OUTER + R_SIGN_INNER) / 2;
      ctx.fillStyle = signColor;
      ctx.font = '400 34px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(SIGN_GLYPHS[sign] || '', Math.cos(midA) * glyphR, Math.sin(midA) * glyphR);
    }

    for (let deg = 0; deg < 360; deg++) {
      const a = longToAngle(deg);
      const isMaj = deg % 10 === 0, isMin = deg % 5 === 0;
      const tick = isMaj ? 8 : isMin ? 5 : 2;
      ctx.strokeStyle = isMaj ? 'rgba(214, 175, 114, 0.3)' : 'rgba(214, 175, 114, 0.12)';
      ctx.lineWidth = isMaj ? 1.2 : 0.6;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a) * R_OUTER, Math.sin(a) * R_OUTER);
      ctx.lineTo(Math.cos(a) * (R_OUTER + tick), Math.sin(a) * (R_OUTER + tick));
      ctx.stroke();
    }

    if (houseCusps.length === 12) {
      for (let i = 0; i < 12; i++) {
        const a = longToAngle(houseCusps[i]);
        const isCard = i === 0 || i === 3 || i === 6 || i === 9;
        ctx.strokeStyle = isCard ? 'rgba(214, 175, 114, 0.4)' : 'rgba(214, 175, 114, 0.15)';
        ctx.lineWidth = isCard ? 1.8 : 0.8;
        const outerR = isCard ? R_OUTER + 12 : R_SIGN_INNER;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(a) * outerR, Math.sin(a) * outerR);
        ctx.stroke();
      }
    }

    // --- Layer 6: Aspect web ---
    const posLongMap: Record<string, number> = {};
    for (const pos of positions) {
      const body = String(pos?.body || '').toLowerCase();
      posLongMap[body] = Number(pos?.longitude || zodiacDegrees(pos?.sign, pos?.degree));
    }

    for (const asp of aspects) {
      const type = String(asp?.type || asp?.aspect_type || '').toLowerCase();
      const sig = String(asp?.significance || '').toLowerCase();
      if (sig === 'minor') continue;
      const color = CHART_ASPECT_COLORS[type];
      if (!color) continue;
      const body1Long = posLongMap[String(asp?.body1 || '').toLowerCase()];
      const body2Long = posLongMap[String(asp?.body2 || '').toLowerCase()];
      if (body1Long == null || body2Long == null) continue;

      const a1 = longToAngle(body1Long), a2 = longToAngle(body2Long);
      const webR = R_INNER - 10;
      const orb = Number(asp?.orb_degrees || asp?.orb || 0);
      const opacity = Math.max(0.15, 0.7 * (1 - orb / 10));

      ctx.strokeStyle = color;
      ctx.globalAlpha = opacity;
      ctx.lineWidth = sig === 'major' ? 1.8 : 1;
      ctx.setLineDash(asp?.applying === false ? [6, 4] : []);

      ctx.beginPath();
      ctx.moveTo(Math.cos(a1) * webR, Math.sin(a1) * webR);
      ctx.lineTo(Math.cos(a2) * webR, Math.sin(a2) * webR);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.setLineDash([]);

    // --- Layer 7: Planet markers (collision avoidance with fan-out) ---
    const MARKER_R = 20;          // circle radius
    const GLYPH_PX = 28;         // glyph font size
    const BASE_ORBIT = 340;
    const ORBIT_STEP = 44;       // radial offset per stagger level
    const MIN_DEG_SEP = 12;      // minimum degrees before fan-out triggers

    const planetData = positions.map((pos: any) => {
      const lng = Number(pos?.longitude || zodiacDegrees(pos?.sign, pos?.degree));
      return { ...pos, _longitude: lng, _angle: longToAngle(lng) };
    }).sort((a: any, b: any) => a._longitude - b._longitude);

    // Assign radial orbits: planets within MIN_DEG_SEP of a prior planet
    // get pushed outward in alternating directions to fan out clusters.
    const displayData = planetData.map((p: any, idx: number) => {
      let clusterDepth = 0;
      for (let j = 0; j < idx; j++) {
        const diff = Math.abs(p._longitude - planetData[j]._longitude);
        if (Math.min(diff, 360 - diff) < MIN_DEG_SEP) clusterDepth++;
      }
      return { ...p, _orbitR: BASE_ORBIT + clusterDepth * ORBIT_STEP };
    });

    for (const pos of displayData) {
      const angle = pos._angle;
      const orbitR = pos._orbitR;
      const x = Math.cos(angle) * orbitR;
      const y = Math.sin(angle) * orbitR;
      const sign = normalizeSign(pos.sign);
      const color = SIGN_COLORS[sign] || '#d6af72';
      const rawBody = String(pos.body || '');
      const body = displayBody(rawBody);
      const glyph = PLANET_GLYPHS[body] || PLANET_GLYPHS[rawBody] || '';
      const retro = Boolean(pos.retrograde);

      // Tick line from inner ring to marker
      ctx.strokeStyle = `${color}50`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(angle) * R_INNER, Math.sin(angle) * R_INNER);
      ctx.lineTo(x, y);
      ctx.stroke();

      // Soft glow behind marker
      const glowG = ctx.createRadialGradient(x, y, 0, x, y, MARKER_R + 10);
      glowG.addColorStop(0, `${color}28`);
      glowG.addColorStop(1, `${color}00`);
      ctx.fillStyle = glowG;
      ctx.beginPath(); ctx.arc(x, y, MARKER_R + 10, 0, Math.PI * 2); ctx.fill();

      // Circle background + border
      ctx.fillStyle = '#080c16';
      ctx.beginPath(); ctx.arc(x, y, MARKER_R, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(x, y, MARKER_R, 0, Math.PI * 2); ctx.stroke();

      // Planetary glyph — fills most of the circle
      ctx.fillStyle = color;
      ctx.font = `400 ${GLYPH_PX}px "Segoe UI Symbol", "EB Garamond", Georgia, serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(glyph, x, y + 1);

      // Retrograde indicator — warm red dot + R badge
      if (retro) {
        const rx = x + MARKER_R + 6, ry = y - MARKER_R + 2;
        ctx.fillStyle = '#c04040';
        ctx.beginPath(); ctx.arc(rx, ry, 9, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#f0e8e0';
        ctx.font = '700 13px "Inter", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('R', rx, ry);
      }
    }

    // --- Layer 8: Angle markers (ASC/MC/DSC/IC) ---
    const angleMarkers = [
      { key: 'ascendant', abbr: 'ASC' },
      { key: 'midheaven', abbr: 'MC' },
      { key: 'descendant', abbr: 'DSC' },
      { key: 'imum coeli', abbr: 'IC' },
    ];
    for (const am of angleMarkers) {
      const found = angles.find((a: any) => String(a?.name || '').toLowerCase() === am.key);
      if (!found) continue;
      const lng = Number(found.longitude || zodiacDegrees(found.sign, found.degree));
      const a = longToAngle(lng);
      const isMain = am.abbr === 'ASC' || am.abbr === 'MC';

      ctx.strokeStyle = isMain ? `${BRASS}70` : `${BRASS}35`;
      ctx.lineWidth = isMain ? 1.8 : 1;
      ctx.setLineDash(isMain ? [] : [8, 6]);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(a) * R_SIGN_INNER, Math.sin(a) * R_SIGN_INNER);
      ctx.stroke();
      ctx.setLineDash([]);

      const lblR = R_INNER - 30;
      ctx.fillStyle = BRASS;
      ctx.font = `600 ${isMain ? 18 : 14}px "Inter", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(am.abbr, Math.cos(a) * lblR, Math.sin(a) * lblR);
    }

    ctx.restore();

    // --- Layer 9: Sign labels outside outer rim ---
    ctx.save();
    for (let i = 0; i < 12; i++) {
      const midA = longToAngle(i * 30 + 15);
      const labelR = R_OUTER + 72;
      const sign = SIGN_ORDER[i];
      ctx.fillStyle = SIGN_COLORS[sign] || '#9aa6c0';
      ctx.font = '600 22px "Inter", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(sign.slice(0, 3).toUpperCase(), Math.cos(midA) * labelR, Math.sin(midA) * labelR);
    }
    ctx.restore();

    ctx.restore();
  }

  async function exportNatalChartImage(chart: Record<string, unknown>) {
    const data = chart as any;
    const positions = Array.isArray(data.positions) ? (data.positions as any[]) : [];
    const angles = Array.isArray(data.angles) ? (data.angles as any[]) : [];
    const aspects = Array.isArray(data.aspects) ? (data.aspects as any[]) : [];
    const houseCusps = Array.isArray(data.house_cusps) ? (data.house_cusps as number[]) : [];
    const houseSystem = String(data.house_system || 'Placidus');
    if (positions.length === 0) throw new Error('No chart data to export.');

    await ensureFontsLoaded();

    // Pre-compute canvas height from data
    const _placementRows = Math.ceil(positions.length / 2);
    const _panelEst = 60
      + (56 + _placementRows * 62 + 14)   // placements
      + 30                                  // divider
      + (42 + 48 + 18)                     // core signature (label + gap + row + pad)
      + 30                                  // divider
      + 50;                                 // footer line
    const H = 1380 + _panelEst + 160;

    const canvas = document.createElement('canvas');
    canvas.width = 1800;
    canvas.height = H;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Could not initialize image export.');

    const W = 1800;
    const CX = 900, CY = 800;
    const BRASS = '#d6af72';

    const ascAngle = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');

    function createSeededRng(pos: any[]): () => number {
      let s = 0;
      for (const p of pos) {
        const lng = Number(p?.longitude || zodiacDegrees(p?.sign, p?.degree));
        s = (s * 31 + Math.round(lng * 100)) | 0;
      }
      s = Math.abs(s) || 12345;
      return () => { s = (s * 1103515245 + 12345) & 0x7fffffff; return s / 0x7fffffff; };
    }

    const rng = createSeededRng(positions);

    function drawRoundedRect(x: number, y: number, w: number, h: number, radius: number) {
      const r = Math.max(0, Math.min(radius, Math.min(w, h) / 2));
      ctx!.beginPath();
      ctx!.moveTo(x + r, y);
      ctx!.lineTo(x + w - r, y);
      ctx!.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx!.lineTo(x + w, y + h - r);
      ctx!.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx!.lineTo(x + r, y + h);
      ctx!.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx!.lineTo(x, y + r);
      ctx!.quadraticCurveTo(x, y, x + r, y);
      ctx!.closePath();
    }

    // --- Layer 1: Background gradient ---
    const bg = ctx.createLinearGradient(0, 0, W, H);
    bg.addColorStop(0, '#05070f');
    bg.addColorStop(0.35, '#0a1228');
    bg.addColorStop(0.65, '#0e0a20');
    bg.addColorStop(1, '#080510');
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, W, H);

    // --- Layer 2: Nebula glows ---
    const nebulae = [
      { x: CX - 200, y: CY - 100, r: 600, color: [70, 110, 180] },
      { x: CX + 250, y: CY + 50, r: 500, color: [180, 145, 80] },
      { x: CX - 50, y: CY + 200, r: 550, color: [90, 50, 130] },
    ];
    for (const n of nebulae) {
      const g = ctx.createRadialGradient(n.x, n.y, 30, n.x, n.y, n.r);
      g.addColorStop(0, `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, 0.18)`);
      g.addColorStop(0.5, `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, 0.06)`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);
    }

    // --- Layer 3: Star field ---
    for (let i = 0; i < 350; i++) {
      const x = rng() * W, y = rng() * H * 0.85;
      const sz = rng() * 1.2 + 0.3, a = rng() * 0.25 + 0.05;
      ctx.fillStyle = `rgba(220, 226, 240, ${a.toFixed(3)})`;
      ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.fill();
    }
    for (let i = 0; i < 80; i++) {
      const x = rng() * W, y = rng() * H * 0.8;
      const sz = rng() * 1.8 + 0.8, a = rng() * 0.45 + 0.2;
      const warm = rng() > 0.5;
      ctx.fillStyle = warm ? `rgba(240, 220, 180, ${a.toFixed(3)})` : `rgba(200, 215, 255, ${a.toFixed(3)})`;
      ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.fill();
    }
    for (let i = 0; i < 12; i++) {
      const x = rng() * W, y = rng() * H * 0.7;
      const sz = rng() * 1.5 + 1.5;
      const halo = ctx.createRadialGradient(x, y, 0, x, y, sz * 6);
      halo.addColorStop(0, 'rgba(220, 230, 255, 0.15)');
      halo.addColorStop(1, 'rgba(220, 230, 255, 0)');
      ctx.fillStyle = halo;
      ctx.beginPath(); ctx.arc(x, y, sz * 6, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(245, 248, 255, 0.8)';
      ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = 'rgba(230, 238, 255, 0.25)';
      ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.moveTo(x - sz * 4, y); ctx.lineTo(x + sz * 4, y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, y - sz * 4); ctx.lineTo(x, y + sz * 4); ctx.stroke();
    }

    drawChartWheel(ctx, chart, 1100, CX, CY);

    // --- Layer 10: Header ---
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';

    ctx.fillStyle = BRASS;
    ctx.font = '600 22px "Inter", sans-serif';
    ctx.fillText('V O I D W I R E', CX, 80);

    ctx.fillStyle = '#efe8d9';
    ctx.font = '400 64px "EB Garamond", Georgia, serif';
    ctx.fillText('Natal Chart', CX, 160);

    ctx.fillStyle = BRASS;
    ctx.save();
    ctx.translate(CX, 200);
    ctx.rotate(Math.PI / 4);
    ctx.fillRect(-5, -5, 10, 10);
    ctx.restore();

    ctx.strokeStyle = `${BRASS}40`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(CX - 120, 200); ctx.lineTo(CX - 18, 200); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(CX + 18, 200); ctx.lineTo(CX + 120, 200); ctx.stroke();

    // --- Layer 11: Data panel (stacked full-width sections) ---
    const panelTop = 1380;
    const panelLeft = 80;
    const panelRight = W - 80;
    const panelW = panelRight - panelLeft;
    const contentLeft = panelLeft + 50;
    const contentRight = panelRight - 50;
    const contentW = contentRight - contentLeft;

    // Pre-sort data for layout calculation
    const sortedPos = [...positions].sort(
      (a, b) => zodiacDegrees(a?.sign, a?.degree) - zodiacDegrees(b?.sign, b?.degree),
    );

    // Layout constants — generous sizing for phone readability
    const placeRowH = 62;
    const coreRowH = 48;
    const placementRows = Math.ceil(sortedPos.length / 2);

    // Pre-compute panel height from data
    const panelHeight = 60
      + 56 + placementRows * placeRowH + 14   // placements
      + 30                                      // divider
      + 42 + coreRowH + 18                     // core signature (label + gap + row + pad)
      + 30                                      // divider
      + 50;                                     // footer line

    // Draw panel background
    ctx.fillStyle = 'rgba(8, 12, 24, 0.8)';
    drawRoundedRect(panelLeft, panelTop, panelW, panelHeight, 24);
    ctx.fill();
    ctx.strokeStyle = 'rgba(214, 175, 114, 0.2)';
    ctx.lineWidth = 1.5;
    drawRoundedRect(panelLeft, panelTop, panelW, panelHeight, 24);
    ctx.stroke();

    // Drawing helpers
    function drawPanelHeader(label: string, y: number): number {
      ctx.fillStyle = BRASS;
      ctx.font = '600 34px "EB Garamond", Georgia, serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
      let xPos = contentLeft;
      for (const ch of label) {
        ctx.fillText(ch, xPos, y);
        xPos += ctx.measureText(ch).width + 2.5;
      }
      ctx.strokeStyle = `${BRASS}20`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(contentLeft, y + 12);
      ctx.lineTo(contentRight, y + 12);
      ctx.stroke();
      return y + 50;
    }

    function drawPanelDivider(y: number): number {
      ctx.strokeStyle = 'rgba(214, 175, 114, 0.10)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(contentLeft + 40, y);
      ctx.lineTo(contentRight - 40, y);
      ctx.stroke();
      return y + 30;
    }

    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    let panelY = panelTop + 60;

    // ── PLACEMENTS (2 columns, inset to align with core signature) ──
    // Centered header with letter-spacing
    ctx.fillStyle = BRASS;
    ctx.font = '600 34px "EB Garamond", Georgia, serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    const _plLabel = 'PLACEMENTS';
    const _plSpacing = 2.5;
    let _plTotalW = 0;
    for (const ch of _plLabel) _plTotalW += ctx.measureText(ch).width + _plSpacing;
    _plTotalW -= _plSpacing;
    let _plX = CX - _plTotalW / 2;
    for (const ch of _plLabel) { ctx.fillText(ch, _plX, panelY); _plX += ctx.measureText(ch).width + _plSpacing; }
    ctx.strokeStyle = `${BRASS}20`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(contentLeft, panelY + 12); ctx.lineTo(contentRight, panelY + 12); ctx.stroke();
    panelY += 56;
    const placeInset = 160;
    const placeLeft = contentLeft + placeInset;
    const placeColW = (contentW - 2 * placeInset) / 2;

    for (let i = 0; i < sortedPos.length; i++) {
      const pos = sortedPos[i];
      const colX = placeLeft + (i % 2) * placeColW;
      const row = Math.floor(i / 2);
      const y = panelY + row * placeRowH;

      const rawBody = String(pos?.body || '');
      const body = displayBody(rawBody);
      const glyph = PLANET_GLYPHS[body] || PLANET_GLYPHS[rawBody] || '';
      const sign = normalizeSign(pos?.sign);
      const deg = Number(pos?.degree || 0).toFixed(1);
      const house = pos?.house ? `H${pos.house}` : '';
      const retro = Boolean(pos?.retrograde);
      const signGlyph = SIGN_GLYPHS[sign] || '';
      const color = SIGN_COLORS[sign] || '#d6af72';

      // Planet glyph
      ctx.fillStyle = color;
      ctx.font = '400 36px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
      ctx.fillText(glyph, colX, y);

      // Planet name
      ctx.fillStyle = '#e0d8c8';
      ctx.font = '600 30px "EB Garamond", Georgia, serif';
      const bodyW = ctx.measureText(body).width;
      ctx.fillText(body, colX + 44, y);

      // Retrograde indicator — muted glyph, blended with palette
      if (retro) {
        ctx.fillStyle = '#8898b8';
        ctx.font = '400 20px "EB Garamond", Georgia, serif';
        ctx.fillText('\u211E', colX + 44 + bodyW + 5, y - 8);
      }

      // Degree · sign · house (inline after name)
      ctx.fillStyle = '#6f7a8e';
      ctx.font = '400 28px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
      const detailX = colX + 44 + bodyW + (retro ? 24 : 12);
      ctx.fillText(`${deg}\u00B0 ${signGlyph} ${sign}${house ? ' \u00B7 ' + house : ''}`, detailX, y);
    }
    panelY += placementRows * placeRowH + 14;

    // ── CORE SIGNATURE (single row, three equal center-aligned columns) ──
    panelY = drawPanelDivider(panelY);
    ctx.fillStyle = `${BRASS}80`;
    ctx.font = '600 22px "EB Garamond", Georgia, serif';
    ctx.textAlign = 'center';
    ctx.fillText('CORE SIGNATURE', CX, panelY + 6);
    ctx.textAlign = 'left';
    panelY += 42;

    const sun = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'sun');
    const moon = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'moon');
    const coreItems = [
      sun ? `${PLANET_GLYPHS['Sun'] || ''} Sun  ${normalizeSign(sun.sign)} ${Number(sun.degree || 0).toFixed(1)}\u00B0` : null,
      moon ? `${PLANET_GLYPHS['Moon'] || ''} Moon  ${normalizeSign(moon.sign)} ${Number(moon.degree || 0).toFixed(1)}\u00B0` : null,
      ascAngle ? `ASC  ${normalizeSign(ascAngle.sign)} ${Number(ascAngle.degree || 0).toFixed(1)}\u00B0` : null,
    ].filter(Boolean) as string[];

    const coreColW = contentW / coreItems.length;
    for (let i = 0; i < coreItems.length; i++) {
      const cx = contentLeft + coreColW * i + coreColW / 2;
      ctx.fillStyle = '#d0c8b8';
      ctx.font = '400 28px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
      ctx.textAlign = 'center';
      ctx.fillText(coreItems[i], cx, panelY);
    }
    ctx.textAlign = 'left';
    panelY += coreRowH + 18;

    // ── Footer: Ascendant · Midheaven · House System ──
    panelY = drawPanelDivider(panelY);
    const mcAngle = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'midheaven' || String(a?.name || '').toLowerCase() === 'mc');
    const footerParts: string[] = [];
    if (ascAngle) footerParts.push(`Asc ${Number(ascAngle.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(ascAngle.sign)}`);
    if (mcAngle) footerParts.push(`MC ${Number(mcAngle.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(mcAngle.sign)}`);
    footerParts.push(houseSystem);
    ctx.fillStyle = '#6f7a8e';
    ctx.font = '400 26px "EB Garamond", Georgia, serif';
    ctx.textAlign = 'center';
    ctx.fillText(footerParts.join('  \u00B7  '), CX, panelY + 14);
    ctx.textAlign = 'left';

    const panelBottom = panelTop + panelHeight;

    // --- Layer 12: Vignette + grain ---
    const vig = ctx.createRadialGradient(CX, H / 2, H * 0.25, CX, H / 2, H * 0.75);
    vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
    vig.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
    vig.addColorStop(1, 'rgba(0, 0, 0, 0.45)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);

    const grainCanvas = document.createElement('canvas');
    grainCanvas.width = 200;
    grainCanvas.height = 200;
    const gctx = grainCanvas.getContext('2d');
    if (gctx) {
      const gData = gctx.createImageData(200, 200);
      for (let i = 0; i < gData.data.length; i += 4) {
        const v = (rng() * 255) | 0;
        gData.data[i] = v; gData.data[i + 1] = v; gData.data[i + 2] = v; gData.data[i + 3] = 255;
      }
      gctx.putImageData(gData, 0, 0);
      ctx.globalAlpha = 0.03;
      ctx.globalCompositeOperation = 'overlay';
      const pattern = ctx.createPattern(grainCanvas, 'repeat');
      if (pattern) { ctx.fillStyle = pattern; ctx.fillRect(0, 0, W, H); }
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }

    // --- Layer 13: Footer (positioned relative to panel bottom) ---
    const footerLineY = panelBottom + 50;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';

    ctx.strokeStyle = `${BRASS}40`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(W * 0.2, footerLineY); ctx.lineTo(W * 0.8, footerLineY); ctx.stroke();

    ctx.fillStyle = `${BRASS}90`;
    ctx.font = '400 22px "JetBrains Mono", monospace';
    ctx.fillText(chartBrandDomain, CX, footerLineY + 40);

    for (let i = -1; i <= 1; i++) {
      ctx.fillStyle = `${BRASS}50`;
      ctx.beginPath(); ctx.arc(CX + i * 16, footerLineY + 76, 2.5, 0, Math.PI * 2); ctx.fill();
    }

    const blob = await new Promise<Blob | null>((resolve) => canvas.toBlob(resolve, 'image/jpeg', 0.92));
    if (!blob) throw new Error('Could not generate chart image.');
    const stamp = new Date().toISOString().slice(0, 10);
    downloadBlob(`voidwire-natal-chart-${stamp}.jpg`, blob);
  }

  async function exportAccountData() {
    try {
      const res = await authFetch('/v1/user/auth/me/export');
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data?.detail || 'Could not export account');
      }
      const payload = await res.json();
      const stamp = new Date().toISOString().slice(0, 10);
      downloadJson(`voidwire-account-${stamp}.json`, payload);
    } catch (err) {
      alert(err instanceof Error ? err.message : 'Could not export account data');
    }
  }

  async function loadDashboard() {
    try {
      const meRes = await authFetch('/v1/user/auth/me');
      if (!meRes.ok) {
        if (meRes.status === 401) {
          clearToken();
          window.location.href = '/login';
          return;
        }
        throw new Error('Failed to load user info');
      }

      const me = (await meRes.json()) as DashboardUser;
      void loadBrandDomain();
      hasProfile = !!me.has_profile;
      canManageReadings = Boolean(me.is_admin_user || me.is_test_user);
      setReadingActionVisibility();
      const userInfo = document.getElementById('user-info');
      if (userInfo) {
        const tier = me.tier === 'pro' ? 'pro' : 'free';
        const displayName = me.display_name ? escapeHtml(me.display_name) : '';
        const roleTag = me.is_admin_user ? 'Admin' : me.is_test_user ? 'Test' : '';
        userInfo.innerHTML = `
          <div class="info-row"><span class="info-label">Email</span><span class="info-value">${escapeHtml(me.email)}</span></div>
          ${displayName ? `<div class="info-row"><span class="info-label">Name</span><span class="info-value">${displayName}</span></div>` : ''}
          <div class="info-row"><span class="info-label">Tier</span><span class="info-value tier-${tier}">${tier.toUpperCase()}</span></div>
          ${roleTag ? `<div class="info-row"><span class="info-label">Privileges</span><span class="info-value">${escapeHtml(roleTag)}</span></div>` : ''}
          <div class="info-row"><span class="info-label">Email Status</span><span class="info-value">${me.email_verified ? 'Verified' : 'Unverified'}</span></div>
        `;
      }

      const onboarding = document.getElementById('onboarding-message');
      const readingSection = document.getElementById('reading-section');
      const profileStatus = document.getElementById('profile-status');
      const birthFormWrapper = document.getElementById('birth-form-wrapper');
      const toggleBirthFormButton = document.getElementById('toggle-birth-form');
      const viewReadingButton = document.getElementById('view-reading-btn') as HTMLButtonElement | null;

      if (!hasProfile) {
        if (onboarding) {
          onboarding.style.display = 'block';
          onboarding.innerHTML = 'Set your birth data in Settings to unlock personalized readings.';
        }
        if (readingSection) readingSection.style.display = 'none';
        const chartStatus = document.getElementById('chart-status');
        if (chartStatus) chartStatus.textContent = 'Add birth data to generate your natal chart.';
        if (profileStatus) {
          profileStatus.innerHTML = '<p class="profile-prompt">Add your birth data to generate natal-chart-based readings.</p>';
        }
        if (birthFormWrapper) birthFormWrapper.style.display = 'block';
        if (toggleBirthFormButton) toggleBirthFormButton.style.display = 'none';
        if (viewReadingButton) viewReadingButton.disabled = true;
        setView('settings');
        return;
      }

      if (onboarding) onboarding.style.display = 'none';
      if (readingSection) readingSection.style.display = 'block';
      if (viewReadingButton) viewReadingButton.disabled = false;

      const profileRes = await authFetch('/v1/user/profile/');
      if (profileRes.ok) {
        const profile = await profileRes.json();
        if (profileStatus) {
          profileStatus.innerHTML = `
            <div class="profile-summary">
              <div class="info-row"><span class="info-label">Birth Date</span><span class="info-value">${escapeHtml(profile.birth_date || '')}</span></div>
              <div class="info-row"><span class="info-label">Location</span><span class="info-value">${escapeHtml(profile.birth_city || '')}</span></div>
              <div class="info-row"><span class="info-label">Timezone</span><span class="info-value">${escapeHtml(profile.birth_timezone || '')}</span></div>
              <div class="info-row"><span class="info-label">House System</span><span class="info-value">${escapeHtml(profile.house_system || '')}</span></div>
            </div>
          `;
        }
      }
      if (toggleBirthFormButton) toggleBirthFormButton.style.display = 'inline-flex';
      if (birthFormWrapper) birthFormWrapper.style.display = 'none';

      void loadNatalChart();
      setView('reading');
      await startReadingFlow();
    } catch (err) {
      console.error('Dashboard load error:', err);
      renderReadingMessage('Could not load dashboard.');
      updateReadingStatus('Could not load dashboard.');
    }
  }

  document.getElementById('view-reading-btn')?.addEventListener('click', () => {
    if (!hasProfile) return;
    setView('reading');
  });

  document.getElementById('view-settings-btn')?.addEventListener('click', () => {
    setView('settings');
  });


  document.getElementById('toggle-birth-form')?.addEventListener('click', () => {
    const birthFormWrapper = document.getElementById('birth-form-wrapper');
    if (!birthFormWrapper) return;
    birthFormWrapper.style.display = birthFormWrapper.style.display === 'none' ? 'block' : 'none';
  });

  document.getElementById('export-chart-text-btn')?.addEventListener('click', async () => {
    if (!cachedChart) return;
    const btn = document.getElementById('export-chart-text-btn') as HTMLButtonElement | null;
    try {
      await navigator.clipboard.writeText(natalChartText(cachedChart));
      if (btn) {
        const original = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = original; }, 2000);
      }
    } catch {
      const stamp = new Date().toISOString().slice(0, 10);
      downloadText(`voidwire-natal-chart-${stamp}.txt`, natalChartText(cachedChart));
    }
  });

  document.getElementById('export-chart-image-btn')?.addEventListener('click', () => {
    if (!cachedChart) return;
    void exportNatalChartImage(cachedChart).catch((err) => {
      alert(err instanceof Error ? err.message : 'Could not export chart image');
    });
  });

  document.getElementById('export-account-btn')?.addEventListener('click', () => {
    void exportAccountData();
  });

  document.getElementById('logout-button')?.addEventListener('click', async () => {
    try {
      await authFetch('/v1/user/auth/logout', { method: 'POST' });
    } catch {
      // Always clear local legacy tokens regardless of network state.
    }
    clearToken();
    window.location.href = '/login';
  });

  window.addEventListener('beforeunload', () => {
    stopReadingPolling();
  });

  void loadDashboard();
</script>

<style>
  .dashboard-container {
    max-width: var(--max-width);
    margin: 1rem auto;
    padding: 0 1.5rem;
  }

  .dashboard-header {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    align-items: center;
  }

  .page-title {
    font-family: var(--font-sans);
    font-size: 0.75rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--accent);
    text-align: center;
    margin-bottom: 0.25rem;
    font-weight: 500;
  }

  .view-toggle {
    display: inline-flex;
    border: 1px solid var(--text-ghost);
  }

  .view-toggle-button {
    background: transparent;
    border: none;
    color: var(--text-muted);
    padding: 0.55rem 1rem;
    font-family: var(--font-sans);
    font-size: 0.62rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    cursor: pointer;
  }

  .view-toggle-button.active {
    color: var(--accent);
    background: var(--accent-glow);
  }

  .view-toggle-button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .onboarding-message {
    font-family: var(--font-sans);
    font-size: 0.8rem;
    color: var(--text-muted);
    text-align: center;
    margin: 1rem 0 0.5rem;
  }

  .section-label {
    font-family: var(--font-sans);
    font-size: 0.6rem;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
    margin-top: 1.2rem;
    padding-bottom: 0.4rem;
    border-bottom: 1px solid var(--text-ghost);
  }

  .reading-status {
    font-family: var(--font-sans);
    font-size: 0.72rem;
    color: var(--text-muted);
    text-align: center;
    margin-bottom: 0.5rem;
  }

  .reading-content :global(.loading),
  .reading-content :global(.muted) {
    font-family: var(--font-sans);
    font-size: 0.8rem;
    color: var(--text-muted);
    text-align: center;
    padding: 2rem;
  }

  .reading-content :global(.reading-tier-badge) {
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--accent);
    text-align: center;
    margin-bottom: 0.75rem;
  }

  .reading-content :global(.reading-title) {
    font-family: var(--font-body);
    font-size: 1.6rem;
    color: var(--text-primary);
    text-align: center;
    font-weight: 400;
    margin-bottom: 0.5rem;
  }

  .reading-content :global(.reading-meta) {
    font-family: var(--font-mono);
    font-size: 0.58rem;
    color: var(--text-muted);
    text-align: center;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    margin-bottom: 1rem;
  }

  .reading-content :global(.reading-body) {
    font-size: 1.05rem;
    color: var(--text-primary);
    line-height: var(--line-height);
  }

  .reading-content :global(.reading-body p) {
    margin-bottom: 1.5em;
  }

  .reading-content :global(.section-heading) {
    font-family: var(--font-sans);
    font-size: 0.65rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--accent);
    margin-top: 1.2rem;
    margin-bottom: 0.5rem;
    font-weight: 500;
  }

  .reading-content :global(.reading-template) {
    margin-top: 1rem;
    font-family: var(--font-mono);
    font-size: 0.6rem;
    color: var(--text-muted);
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }

  .reading-actions {
    display: none;
    flex-wrap: wrap;
    gap: 0.6rem;
    margin-top: 0.6rem;
  }

  .reading-actions.visible {
    display: flex;
  }

  .chart-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.6rem;
    margin-top: 0.6rem;
  }

  :global(.action-button),
  :global(.edit-button) {
    background: transparent;
    border: 1px solid var(--text-ghost);
    color: var(--text-secondary);
    padding: 0.55rem 0.9rem;
    font-family: var(--font-sans);
    font-size: 0.62rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  :global(.action-button:hover),
  :global(.edit-button:hover) {
    border-color: var(--accent);
    color: var(--accent);
  }

  .user-info,
  .profile-summary {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  :global(.info-row) {
    display: flex;
    justify-content: space-between;
    font-family: var(--font-sans);
    font-size: 0.8rem;
    padding: 0.3rem 0;
  }

  :global(.info-label) {
    color: var(--text-muted);
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  :global(.info-value) {
    color: var(--text-secondary);
  }

  :global(.tier-pro) {
    color: var(--accent);
    font-weight: 500;
  }

  :global(.profile-prompt) {
    font-family: var(--font-sans);
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-bottom: 1rem;
  }

  .chart-wheel-wrap {
    display: flex;
    justify-content: center;
    margin: 0.8rem 0 1.2rem;
  }

  .chart-wheel-wrap canvas {
    border-radius: 12px;
    max-width: 100%;
    height: auto !important;
  }

  .chart-content {
    margin-top: 0.8rem;
  }

  .chart-content :global(.chart-hero) {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    padding: 1rem 0;
    margin-bottom: 1rem;
    border-top: 1px solid var(--text-ghost);
    border-bottom: 1px solid var(--text-ghost);
  }

  .chart-content :global(.chart-hero-item) {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.2rem;
  }

  .chart-content :global(.chart-hero-glyph) {
    font-family: "Segoe UI Symbol", "EB Garamond", Georgia, serif;
    font-size: 1.4rem;
    line-height: 1;
  }

  .chart-content :global(.chart-hero-label) {
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--text-muted);
  }

  .chart-content :global(.chart-hero-detail) {
    font-family: "Segoe UI Symbol", var(--font-body);
    font-size: 0.8rem;
    color: var(--text-secondary);
  }

  .chart-content :global(.chart-placements) {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.15rem 1.5rem;
    margin-bottom: 1rem;
  }

  .chart-content :global(.chart-placement) {
    display: flex;
    align-items: baseline;
    gap: 0.4rem;
    padding: 0.35rem 0;
    font-family: var(--font-sans);
    font-size: 0.78rem;
  }

  .chart-content :global(.chart-placement-glyph) {
    font-family: "Segoe UI Symbol", "EB Garamond", Georgia, serif;
    font-size: 1rem;
    flex-shrink: 0;
    width: 1.2rem;
    text-align: center;
  }

  .chart-content :global(.chart-placement-name) {
    color: var(--text-primary);
    font-weight: 500;
    white-space: nowrap;
  }

  .chart-content :global(.chart-retro) {
    color: var(--text-muted);
    font-size: 0.7rem;
    margin-left: 0.15rem;
  }

  .chart-content :global(.chart-placement-detail) {
    font-family: "Segoe UI Symbol", var(--font-body);
    color: var(--text-muted);
    font-size: 0.72rem;
    white-space: nowrap;
  }

  .chart-content :global(.chart-detail-footer) {
    text-align: center;
    font-family: var(--font-mono);
    font-size: 0.6rem;
    letter-spacing: 0.08em;
    color: var(--text-muted);
    padding-top: 0.6rem;
    border-top: 1px solid var(--text-ghost);
  }

  .logout-wrapper {
    text-align: center;
    margin: 2rem 0 3rem;
  }

  .logout-button {
    background: transparent;
    border: 1px solid var(--text-ghost);
    color: var(--text-muted);
    padding: 0.6rem 2rem;
    font-family: var(--font-sans);
    font-size: 0.65rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .logout-button:hover {
    border-color: #c45;
    color: #c45;
  }

  @media (max-width: 768px) {
    .dashboard-container {
      margin: 0.5rem auto;
      padding: 0 1rem;
    }

    .dashboard-header {
      gap: 0.3rem;
    }

    .section-label {
      margin-top: 0.8rem;
      margin-bottom: 0.3rem;
    }

    .reading-content :global(.loading),
    .reading-content :global(.muted) {
      padding: 1rem;
    }

    .reading-content :global(.reading-meta) {
      margin-bottom: 0.75rem;
    }

    .reading-content :global(.section-heading) {
      margin-top: 0.8rem;
    }

    .logout-wrapper {
      margin: 1.5rem 0 2rem;
    }

    .chart-content :global(.chart-hero) {
      gap: 1rem;
      padding: 0.75rem 0;
    }

    .chart-content :global(.chart-hero-glyph) {
      font-size: 1.1rem;
    }

    .chart-content :global(.chart-placements) {
      grid-template-columns: 1fr;
      gap: 0.1rem;
    }
  }
</style>
