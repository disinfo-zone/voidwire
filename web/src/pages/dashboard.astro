---
import Base from '../layouts/Base.astro';
import Background from '../components/Background.svelte';
import BirthDataForm from '../components/BirthDataForm.svelte';
import SubscriptionManager from '../components/SubscriptionManager.svelte';
---

<Base title="Dashboard">
  <Background />

  <header class="site-header">
    <div class="site-title"><a href="/">VOIDWIRE</a></div>
    <nav class="site-nav">
      <a href="/archive">Archive</a>
      <a href="/events">Events</a>
      <a href="/about">About</a>
    </nav>
  </header>

  <main>
    <div id="dashboard-content" style="display: none;">
      <div class="dashboard-container">
        <div class="dashboard-header">
          <h1 class="page-title">Your Dashboard</h1>
          <div class="view-toggle">
            <button id="view-reading-btn" class="view-toggle-button active">Reading</button>
            <button id="view-settings-btn" class="view-toggle-button">Settings</button>
          </div>
        </div>

        <div id="onboarding-message" class="onboarding-message" style="display: none;"></div>

        <section id="reading-section" class="reading-section" style="display: none;">
          <div id="reading-status" class="reading-status" style="display: none;"></div>
          <div id="reading-content" class="reading-content">
            <div class="loading">Tuning into the wire&hellip;</div>
          </div>
          <div id="reading-actions" class="reading-actions"></div>
          <div id="transit-overlay" class="transit-overlay" style="display: none;">
            <div class="section-label" data-tip="Where the planets are right now, overlaid on your natal chart &mdash; showing how today&rsquo;s sky activates your birth chart">Current Transits</div>
            <div class="chart-wheel-wrap">
              <canvas id="transit-wheel-canvas"></canvas>
            </div>
            <div id="transit-content" class="chart-content"></div>
          </div>
        </section>

        <section id="settings-section" class="settings-section" style="display: none;">
          <div class="section-label">Natal Chart</div>
          <div id="chart-status" class="chart-skeleton">
            <div class="skeleton-wheel"></div>
            <div class="skeleton-lines">
              <div class="skeleton-line"></div>
              <div class="skeleton-line short"></div>
              <div class="skeleton-line"></div>
              <div class="skeleton-line short"></div>
            </div>
          </div>
          <div class="chart-wheel-wrap">
            <canvas id="chart-wheel-canvas"></canvas>
            <div class="chart-actions chart-actions-centered">
              <button id="export-chart-text-btn" class="action-button" style="display: none;">Copy Chart</button>
              <button id="export-chart-image-btn" class="action-button" style="display: none;">Share Chart Image</button>
            </div>
          </div>
          <div id="chart-content" class="chart-content"></div>

          <div class="section-label section-toggle" data-target="birth-data-body">Birth Data</div>
          <div id="birth-data-body" class="section-body collapsed">
            <div id="profile-status" class="profile-status"></div>
            <button id="toggle-birth-form" class="edit-button" style="display: none;">Edit Birth Data</button>
            <div id="birth-form-wrapper" style="display: none;">
              <BirthDataForm client:visible onSave={() => window.location.reload()} />
            </div>
          </div>

          <div class="section-label section-toggle" data-target="account-body">Account</div>
          <div id="account-body" class="section-body collapsed">
            <div id="user-info" class="user-info"></div>
            <button id="delete-account-link" class="delete-account-link">Delete Account</button>
          </div>

          <div class="section-label section-toggle" data-target="subscription-body">Subscription</div>
          <div id="subscription-body" class="section-body collapsed">
            <SubscriptionManager client:visible />
          </div>

          <div class="section-label section-toggle" data-target="data-export-body">Data Export</div>
          <div id="data-export-body" class="section-body collapsed">
            <div class="chart-actions">
              <button id="export-account-btn" class="action-button">Export Account JSON</button>
            </div>
          </div>
        </section>

        <div class="logout-wrapper">
          <button id="logout-button" class="logout-button">Logout</button>
        </div>
      </div>
    </div>

    <div id="delete-account-modal" class="modal-overlay" style="display: none;">
      <div class="modal-content">
        <div class="modal-title">Delete Account</div>
        <p>This action is permanent and cannot be undone. All your data will be deleted.</p>
        <p>Type <strong>DELETE</strong> to confirm.</p>
        <input id="delete-confirm-input" type="text" placeholder="Type DELETE" autocomplete="off" />
        <div id="delete-error" class="modal-error"></div>
        <div id="delete-password-row" class="modal-password-row" style="display: none;">
          <input id="delete-password-input" type="password" placeholder="Enter your password" />
        </div>
        <div class="modal-actions">
          <button id="delete-cancel-btn" class="action-button">Cancel</button>
          <button id="delete-confirm-btn" class="action-button danger-button" disabled>Delete My Account</button>
        </div>
      </div>
    </div>
  </main>
</Base>

<script>
  import { clearToken, authFetch } from '../utils/auth';

  type DashboardUser = {
    id: string;
    email: string;
    email_verified: boolean;
    display_name: string | null;
    has_profile: boolean;
    tier: 'free' | 'pro';
    is_admin_user?: boolean;
    is_test_user?: boolean;
    can_manage_readings?: boolean;
    created_at: string | null;
  };

  type ReadingPayload = {
    tier: 'free' | 'pro';
    title: string;
    body: string;
    sections: { heading: string; body: string }[];
    word_count: number;
    date_context: string;
    coverage_label?: string;
    coverage_start?: string;
    coverage_end?: string;
    template_version?: string;
  };

  const content = document.getElementById('dashboard-content');
  if (content) content.style.display = 'block';

  let hasProfile = false;
  let canManageReadings = false;
  let activeJobId: string | null = null;
  let readingPollTimer: number | null = null;
  let readingPollStartedAt = 0;
  let cachedChart: Record<string, unknown> | null = null;
  let chartPlanetScreenPositions: Array<{ body: string; sx: number; sy: number; sign: string; deg: string; house: string; retro: boolean }> = [];
  let chartBrandDomain = 'voidwire.app';
  const SIGN_ORDER = [
    'Aries',
    'Taurus',
    'Gemini',
    'Cancer',
    'Leo',
    'Virgo',
    'Libra',
    'Scorpio',
    'Sagittarius',
    'Capricorn',
    'Aquarius',
    'Pisces',
  ];
  const SIGN_COLORS: Record<string, string> = {
    Aries: '#ff8b7b',
    Taurus: '#e3c470',
    Gemini: '#f1ea86',
    Cancer: '#9fd2ff',
    Leo: '#ffcc6a',
    Virgo: '#bce68f',
    Libra: '#b9a3ff',
    Scorpio: '#df8fff',
    Sagittarius: '#ffad80',
    Capricorn: '#8ec5b8',
    Aquarius: '#90d0ff',
    Pisces: '#a0a6ff',
  };
  const VS15 = '\uFE0E';
  const PLANET_GLYPHS: Record<string, string> = {
    Sun: `\u2609${VS15}`, Moon: `\u263D${VS15}`, Mercury: `\u263F${VS15}`, Venus: `\u2640${VS15}`,
    Mars: `\u2642${VS15}`, Jupiter: `\u2643${VS15}`, Saturn: `\u2644${VS15}`, Uranus: `\u2645${VS15}`,
    Neptune: `\u2646${VS15}`, Pluto: `\u2647${VS15}`, Chiron: `\u26B7${VS15}`, 'North Node': `\u260A${VS15}`,
  };
  const SIGN_GLYPHS: Record<string, string> = {
    Aries: `\u2648${VS15}`, Taurus: `\u2649${VS15}`, Gemini: `\u264A${VS15}`, Cancer: `\u264B${VS15}`,
    Leo: `\u264C${VS15}`, Virgo: `\u264D${VS15}`, Libra: `\u264E${VS15}`, Scorpio: `\u264F${VS15}`,
    Sagittarius: `\u2650${VS15}`, Capricorn: `\u2651${VS15}`, Aquarius: `\u2652${VS15}`, Pisces: `\u2653${VS15}`,
  };
  const CHART_ASPECT_COLORS: Record<string, string> = {
    conjunction: '#d6af72', opposition: '#e07060', trine: '#5888c8',
    square: '#c04040', sextile: '#50a868',
  };
  const ASPECT_GLYPHS: Record<string, string> = {
    conjunction: `\u260C${VS15}`, opposition: `\u260D${VS15}`, trine: '\u25B3',
    square: '\u25A1', sextile: `\u26B9${VS15}`,
  };
  const ELEMENT_MAP: Record<string, string> = {
    Aries: 'Fire', Taurus: 'Earth', Gemini: 'Air', Cancer: 'Water',
    Leo: 'Fire', Virgo: 'Earth', Libra: 'Air', Scorpio: 'Water',
    Sagittarius: 'Fire', Capricorn: 'Earth', Aquarius: 'Air', Pisces: 'Water',
  };
  const MODALITY_MAP: Record<string, string> = {
    Aries: 'Cardinal', Taurus: 'Fixed', Gemini: 'Mutable', Cancer: 'Cardinal',
    Leo: 'Fixed', Virgo: 'Mutable', Libra: 'Cardinal', Scorpio: 'Fixed',
    Sagittarius: 'Mutable', Capricorn: 'Cardinal', Aquarius: 'Fixed', Pisces: 'Mutable',
  };
  const PLANET_TIPS: Record<string, string> = {
    Sun: 'Core identity, ego, and life purpose',
    Moon: 'Emotions, instincts, and inner world',
    Mercury: 'Communication, thought, and learning',
    Venus: 'Love, beauty, and values',
    Mars: 'Drive, energy, and assertion',
    Jupiter: 'Growth, luck, and expansion',
    Saturn: 'Discipline, structure, and lessons',
    Uranus: 'Innovation, rebellion, and change',
    Neptune: 'Dreams, intuition, and spirituality',
    Pluto: 'Transformation, power, and rebirth',
    Chiron: 'Healing, wounds, and wisdom',
    'North Node': 'Life direction and soul growth',
  };
  const SIGN_TIPS: Record<string, string> = {
    Aries: 'Cardinal Fire \u2014 bold, pioneering, assertive',
    Taurus: 'Fixed Earth \u2014 steady, sensual, resourceful',
    Gemini: 'Mutable Air \u2014 curious, versatile, communicative',
    Cancer: 'Cardinal Water \u2014 nurturing, intuitive, protective',
    Leo: 'Fixed Fire \u2014 creative, generous, expressive',
    Virgo: 'Mutable Earth \u2014 analytical, helpful, precise',
    Libra: 'Cardinal Air \u2014 harmonious, diplomatic, aesthetic',
    Scorpio: 'Fixed Water \u2014 intense, transformative, perceptive',
    Sagittarius: 'Mutable Fire \u2014 adventurous, philosophical, optimistic',
    Capricorn: 'Cardinal Earth \u2014 ambitious, disciplined, strategic',
    Aquarius: 'Fixed Air \u2014 innovative, humanitarian, independent',
    Pisces: 'Mutable Water \u2014 empathic, imaginative, transcendent',
  };
  const ASPECT_TIPS: Record<string, string> = {
    conjunction: 'Fusion of energies \u2014 intensification and focus',
    opposition: 'Tension and polarity \u2014 awareness through contrast',
    trine: 'Harmony and flow \u2014 natural ease and talent',
    square: 'Friction and challenge \u2014 catalyst for growth',
    sextile: 'Opportunity and cooperation \u2014 gentle support',
  };
  const HOUSE_TIPS: Record<string, string> = {
    '1': 'Self, appearance, and first impressions',
    '2': 'Values, resources, and self-worth',
    '3': 'Communication, siblings, and local environment',
    '4': 'Home, family, and emotional foundations',
    '5': 'Creativity, romance, and self-expression',
    '6': 'Health, daily routines, and service',
    '7': 'Partnerships, relationships, and contracts',
    '8': 'Transformation, shared resources, and intimacy',
    '9': 'Philosophy, travel, and higher learning',
    '10': 'Career, public image, and ambition',
    '11': 'Community, hopes, and social networks',
    '12': 'Unconscious, solitude, and transcendence',
  };
  const ELEMENT_TIPS: Record<string, string> = {
    Fire: 'Passion, action, and inspiration',
    Earth: 'Stability, practicality, and groundedness',
    Air: 'Intellect, communication, and ideas',
    Water: 'Emotion, intuition, and depth',
  };
  const MODALITY_TIPS: Record<string, string> = {
    Cardinal: 'Initiative, leadership, and new beginnings',
    Fixed: 'Persistence, determination, and stability',
    Mutable: 'Adaptability, flexibility, and change',
  };
  const DIGNITY_TABLE: Record<string, { domicile: string[]; exaltation: string; detriment: string[]; fall: string }> = {
    Sun: { domicile: ['Leo'], exaltation: 'Aries', detriment: ['Aquarius'], fall: 'Libra' },
    Moon: { domicile: ['Cancer'], exaltation: 'Taurus', detriment: ['Capricorn'], fall: 'Scorpio' },
    Mercury: { domicile: ['Gemini', 'Virgo'], exaltation: 'Virgo', detriment: ['Sagittarius', 'Pisces'], fall: 'Pisces' },
    Venus: { domicile: ['Taurus', 'Libra'], exaltation: 'Pisces', detriment: ['Aries', 'Scorpio'], fall: 'Virgo' },
    Mars: { domicile: ['Aries', 'Scorpio'], exaltation: 'Capricorn', detriment: ['Taurus', 'Libra'], fall: 'Cancer' },
    Jupiter: { domicile: ['Sagittarius', 'Pisces'], exaltation: 'Cancer', detriment: ['Gemini', 'Virgo'], fall: 'Capricorn' },
    Saturn: { domicile: ['Capricorn', 'Aquarius'], exaltation: 'Libra', detriment: ['Cancer', 'Leo'], fall: 'Aries' },
  };
  const DIGNITY_LABELS: Record<string, { symbol: string; label: string; tip: string }> = {
    domicile: { symbol: '\u2302', label: 'Domicile', tip: 'Planet in its home sign \u2014 strongest, most natural expression' },
    exaltation: { symbol: '\u2191', label: 'Exalted', tip: 'Planet in its exaltation sign \u2014 honored, elevated expression' },
    detriment: { symbol: '\u2193', label: 'Detriment', tip: 'Planet in its detriment \u2014 challenged, must work harder to express' },
    fall: { symbol: '\u2913', label: 'Fall', tip: 'Planet in its fall \u2014 weakened, requires conscious effort' },
  };
  const SIGN_RULERS: Record<string, string> = {
    Aries: 'Mars', Taurus: 'Venus', Gemini: 'Mercury', Cancer: 'Moon',
    Leo: 'Sun', Virgo: 'Mercury', Libra: 'Venus', Scorpio: 'Pluto',
    Sagittarius: 'Jupiter', Capricorn: 'Saturn', Aquarius: 'Uranus', Pisces: 'Neptune',
  };

  function getDignity(body: string, sign: string): string | null {
    const entry = DIGNITY_TABLE[body];
    if (!entry) return null;
    if (entry.domicile.includes(sign)) return 'domicile';
    if (entry.exaltation === sign) return 'exaltation';
    if (entry.detriment.includes(sign)) return 'detriment';
    if (entry.fall === sign) return 'fall';
    return null;
  }

  function detectChartPattern(longitudes: number[]): { name: string; description: string } {
    if (longitudes.length < 4) return { name: 'Unknown', description: '' };
    const sorted = [...longitudes].sort((a, b) => a - b);
    const gaps: number[] = [];
    for (let i = 0; i < sorted.length; i++) {
      const next = (i + 1) % sorted.length;
      let gap = sorted[next] - sorted[i];
      if (gap <= 0) gap += 360;
      gaps.push(gap);
    }
    const maxGap = Math.max(...gaps);
    const span = 360 - maxGap;
    const bigGaps = gaps.filter((g) => g > 60).length;

    if (span <= 120) return { name: 'Bundle', description: 'All planets concentrated within 120\u00B0 \u2014 intense focus and specialization' };

    // Bucket: bowl shape but one planet is isolated on the other side
    if (span <= 200) {
      const gapIdx = gaps.indexOf(maxGap);
      const isolatedIdx = (gapIdx + 1) % sorted.length;
      const oppGapStart = sorted[gapIdx];
      const oppGapEnd = sorted[isolatedIdx];
      let secondGap = 0;
      const othersNoIsolated = gaps.filter((_, i) => i !== gapIdx);
      if (othersNoIsolated.length > 0) secondGap = Math.max(...othersNoIsolated);
      if (maxGap > 150 && secondGap < 60) {
        return { name: 'Bucket', description: 'Bowl shape with one planet as the handle \u2014 a focal point channeling concentrated energy' };
      }
      if (span <= 180) return { name: 'Bowl', description: 'All planets within one hemisphere \u2014 self-contained energy with a strong sense of purpose' };
    }

    if (maxGap >= 100 && maxGap <= 150) return { name: 'Locomotive', description: 'Planets span 240\u00B0 with an empty sector \u2014 drive and determination with a missing quality to develop' };

    // See-Saw: two groups separated by two gaps > 60°
    if (bigGaps === 2) return { name: 'See-Saw', description: 'Two opposing groups of planets \u2014 awareness of contrasts, seeking balance between extremes' };

    if (bigGaps >= 3) return { name: 'Splay', description: 'Planets in distinct clusters \u2014 individualistic, strong-willed, multi-talented' };

    return { name: 'Splash', description: 'Planets distributed across most of the zodiac \u2014 versatile with wide-ranging interests' };
  }

  function escapeHtml(value: unknown): string {
    return String(value ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  function paragraphsToHtml(value: unknown): string {
    return String(value ?? '')
      .split(/\n\n+/)
      .map((p) => p.trim())
      .filter(Boolean)
      .map((p) => `<p>${escapeHtml(p)}</p>`)
      .join('');
  }

  function sectionToHtml(section: any): string {
    const heading = escapeHtml(section?.heading ?? '');
    const body = paragraphsToHtml(section?.body ?? '');
    return `<div class="section"><h3 class="section-heading">${heading}</h3>${body}</div>`;
  }

  function normalizeSign(sign: unknown): string {
    const raw = String(sign || '').trim().toLowerCase();
    return SIGN_ORDER.find((entry) => entry.toLowerCase() === raw) || String(sign || '').trim();
  }

  function zodiacDegrees(sign: unknown, degree: unknown): number {
    const normalized = normalizeSign(sign);
    const signIndex = SIGN_ORDER.findIndex((entry) => entry === normalized);
    const safeDegree = Number.isFinite(Number(degree)) ? Number(degree) : 0;
    const boundedDegree = ((safeDegree % 30) + 30) % 30;
    if (signIndex < 0) return boundedDegree;
    return signIndex * 30 + boundedDegree;
  }

  function bodyAbbreviation(body: unknown): string {
    const label = String(body || '').trim();
    if (!label) return '?';
    if (label.length <= 3) return label.toUpperCase();
    if (label.toLowerCase() === 'north node') return 'NN';
    if (label.toLowerCase() === 'south node') return 'SN';
    return label.slice(0, 2).toUpperCase();
  }

  /** Convert raw body names (snake_case, lowercase) to display-ready labels. */
  function displayBody(raw: unknown): string {
    const s = String(raw || '').trim();
    if (!s) return '';
    // Replace underscores/hyphens with spaces, then Title Case each word
    return s.replace(/[_-]/g, ' ').replace(/\b\w/g, (c) => c.toUpperCase());
  }

  function siteDomainLabel(value: unknown): string {
    const raw = String(value || '').trim();
    if (!raw) return 'voidwire.app';

    const withoutProtocol = raw.replace(/^https?:\/\//i, '');
    const withoutQuery = withoutProtocol.split(/[?#]/)[0] || withoutProtocol;
    try {
      const parsed = new URL(raw.startsWith('http://') || raw.startsWith('https://') ? raw : `https://${raw}`);
      const path = parsed.pathname && parsed.pathname !== '/' ? parsed.pathname.replace(/\/+$/, '') : '';
      return `${parsed.host}${path}` || withoutQuery;
    } catch {
      return withoutQuery.replace(/\/+$/, '') || 'voidwire.app';
    }
  }

  function setReadingActionVisibility() {
    const readingActions = document.getElementById('reading-actions') as HTMLElement | null;
    if (!readingActions) return;
    if (!canManageReadings) {
      readingActions.innerHTML = '';
      readingActions.classList.remove('visible');
      return;
    }
    if (!readingActions.querySelector('#refresh-reading-btn')) {
      readingActions.innerHTML =
        '<button id="refresh-reading-btn" class="action-button">Refresh</button>' +
        '<button id="generate-reading-btn" class="action-button">Generate Latest</button>';
      document.getElementById('refresh-reading-btn')?.addEventListener('click', () => {
        if (!canManageReadings) return;
        void startReadingFlow();
      });
      document.getElementById('generate-reading-btn')?.addEventListener('click', async () => {
        if (!hasProfile || !canManageReadings) return;
        stopReadingPolling();
        activeJobId = null;
        updateReadingStatus('Requesting a fresh transmission\u2026');
        renderReadingMessage('Clearing the channel for a new transmission\u2026');
        try {
          activeJobId = await enqueueOrReuseReadingJob({ forceRefresh: true, reuseActive: false });
          readingPollStartedAt = Date.now();
          await pollReadingJob();
          if (activeJobId) {
            readingPollTimer = window.setInterval(() => {
              void pollReadingJob();
            }, 4000);
          }
        } catch (err) {
          renderReadingMessage(err instanceof Error ? err.message : 'The reading could not be channeled');
          updateReadingStatus('The signal was lost in the void.');
        }
      });
    }
    readingActions.classList.add('visible');
  }

  async function loadBrandDomain() {
    try {
      const res = await fetch('/v1/site/config', { credentials: 'include' });
      if (!res.ok) return;
      const cfg = await res.json();
      chartBrandDomain = siteDomainLabel(cfg?.site_url);
    } catch {
      chartBrandDomain = chartBrandDomain || 'voidwire.app';
    }
  }

  function setView(view: 'reading' | 'settings') {
    const readingSection = document.getElementById('reading-section');
    const settingsSection = document.getElementById('settings-section');
    const readingBtn = document.getElementById('view-reading-btn');
    const settingsBtn = document.getElementById('view-settings-btn');
    if (readingSection) readingSection.style.display = view === 'reading' ? 'block' : 'none';
    if (settingsSection) settingsSection.style.display = view === 'settings' ? 'block' : 'none';
    readingBtn?.classList.toggle('active', view === 'reading');
    settingsBtn?.classList.toggle('active', view === 'settings');
  }

  function updateReadingStatus(message: string) {
    const status = document.getElementById('reading-status');
    if (status) {
      status.textContent = message;
      (status as HTMLElement).style.display = message ? 'block' : 'none';
    }
  }

  function stopReadingPolling() {
    if (readingPollTimer !== null) {
      window.clearInterval(readingPollTimer);
      readingPollTimer = null;
    }
    activeJobId = null;
  }

  function downloadBlob(filename: string, blob: Blob) {
    const url = URL.createObjectURL(blob);
    const anchor = document.createElement('a');
    anchor.href = url;
    anchor.download = filename;
    anchor.click();
    URL.revokeObjectURL(url);
  }

  function downloadJson(filename: string, payload: unknown) {
    downloadBlob(filename, new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' }));
  }

  function downloadText(filename: string, text: string) {
    downloadBlob(filename, new Blob([text], { type: 'text/plain;charset=utf-8' }));
  }

  function renderReading(reading: ReadingPayload) {
    const readingContent = document.getElementById('reading-content');
    if (!readingContent) return;

    const tierLabel = reading.tier === 'pro' ? 'Daily Pro Reading' : 'Weekly Reading';
    const bodyHtml = paragraphsToHtml(reading.body);
    const sections = Array.isArray(reading.sections) ? reading.sections : [];
    const sectionsHtml = sections.length > 0 ? sections.map((s) => sectionToHtml(s)).join('') : '';
    const safeTitle = escapeHtml(reading.title);
    const safeDateContext = escapeHtml(reading.date_context);
    const safeCoverage = escapeHtml(reading.coverage_label || '');
    const safeWordCount = Number(reading.word_count) || 0;
    const safeTemplate = reading.template_version ? escapeHtml(reading.template_version) : '';
    const showTemplate = canManageReadings && !!safeTemplate;

    // Detach transit overlay before wiping innerHTML so it isn't destroyed
    const transitOverlay = document.getElementById('transit-overlay');
    if (transitOverlay && transitOverlay.parentElement) {
      transitOverlay.parentElement.removeChild(transitOverlay);
    }

    readingContent.innerHTML = `
      <div class="reading-tier-badge">${escapeHtml(tierLabel)}</div>
      <h2 class="reading-title">${safeTitle}</h2>
      <div class="reading-meta">${safeDateContext}${safeCoverage ? ` · ${safeCoverage}` : ''} · ${safeWordCount} words</div>
      <div class="reading-body">${bodyHtml}</div>
      ${sectionsHtml}
      ${showTemplate ? `<div class="reading-template">Template: ${safeTemplate}</div>` : ''}
    `;
    // Re-insert transit overlay after all reading content
    if (transitOverlay) {
      readingContent.appendChild(transitOverlay);
    }
    setReadingActionVisibility();
    updateReadingStatus('');
    // Trigger transit overlay load in case chart data is already available
    void loadTransitOverlay();
  }

  function renderReadingMessage(message: string) {
    const readingContent = document.getElementById('reading-content');
    if (!readingContent) return;
    readingContent.innerHTML = `<p class="muted">${escapeHtml(message)}</p>`;
  }

  async function fetchCurrentReading(): Promise<ReadingPayload | null> {
    const readingRes = await authFetch('/v1/user/readings/personal/current');
    if (readingRes.status === 404) return null;
    if (readingRes.status === 503) {
      renderReadingMessage('Personal reading LLM slot is not configured yet. Ask your admin to configure personal_free/personal_pro.');
      updateReadingStatus('Reading generation unavailable.');
      throw new Error('Reading generation unavailable');
    }
    if (!readingRes.ok) {
      const data = await readingRes.json().catch(() => ({}));
      throw new Error(data?.detail || 'Could not load reading');
    }
    return await readingRes.json();
  }

  async function enqueueOrReuseReadingJob(options?: { forceRefresh?: boolean; reuseActive?: boolean }) {
    const forceRefresh = Boolean(options?.forceRefresh);
    const reuseActive = options?.reuseActive !== false;
    if (reuseActive) {
      const jobsRes = await authFetch('/v1/user/readings/personal/jobs?limit=20');
      if (jobsRes.ok) {
        const jobs = await jobsRes.json();
        if (Array.isArray(jobs)) {
          const today = new Date().toISOString().slice(0, 10);
          const active = jobs.find((job: any) => {
            const jobForce = Boolean(job?.payload?.force_refresh);
            return (
              (job.status === 'queued' || job.status === 'running') &&
              String(job?.payload?.target_date || '') === today &&
              jobForce === forceRefresh
            );
          });
          if (active?.id) return String(active.id);
        }
      }
    }
    const createRes = await authFetch('/v1/user/readings/personal/jobs', {
      method: 'POST',
      body: JSON.stringify({ tier: 'auto', force_refresh: forceRefresh }),
    });
    if (!createRes.ok) {
      const data = await createRes.json().catch(() => ({}));
      throw new Error(data?.detail || 'Failed to start reading generation');
    }
    const job = await createRes.json();
    if (!job?.id) throw new Error('Reading job was not created');
    return String(job.id);
  }

  async function pollReadingJob() {
    if (!activeJobId) return;
    const elapsed = Math.max(Math.round((Date.now() - readingPollStartedAt) / 1000), 1);
    const statusRes = await authFetch(`/v1/user/readings/personal/jobs/${activeJobId}`);
    if (!statusRes.ok) {
      updateReadingStatus('Lost contact with the signal.');
      return;
    }
    const job = await statusRes.json();
    const jobStatus = String(job?.status || 'queued');
    if (jobStatus === 'queued' || jobStatus === 'running') {
      updateReadingStatus(`Channeling the celestial signal\u2026 ${elapsed}s elapsed. Deep readings may take a few minutes.`);
      return;
    }
    if (jobStatus === 'failed') {
      stopReadingPolling();
      const message = String(job?.error_message || 'The reading could not be channeled');
      renderReadingMessage(message);
      updateReadingStatus('The signal was lost in the void.');
      return;
    }
    if (jobStatus === 'completed') {
      stopReadingPolling();
      const reading = await fetchCurrentReading();
      if (reading) {
        renderReading(reading);
      } else {
        renderReadingMessage('The transmission has arrived but has not yet materialized. Refresh in a moment.');
        updateReadingStatus('Transmission received. Awaiting materialization.');
      }
    }
  }

  async function startReadingFlow() {
    if (!hasProfile) return;
    updateReadingStatus('Scanning the celestial wire\u2026');
    try {
      const reading = await fetchCurrentReading();
      if (reading) {
        renderReading(reading);
        stopReadingPolling();
        return;
      }

      const readingContent = document.getElementById('reading-content');
      if (readingContent) {
        readingContent.innerHTML = '<div class="loading">Attuning to your natal frequency\u2026</div>';
      }
      stopReadingPolling();
      activeJobId = await enqueueOrReuseReadingJob();
      readingPollStartedAt = Date.now();
      updateReadingStatus('Awaiting celestial alignment\u2026');
      await pollReadingJob();
      if (activeJobId) {
        readingPollTimer = window.setInterval(() => {
          void pollReadingJob();
        }, 4000);
      }
    } catch (err) {
      renderReadingMessage(err instanceof Error ? err.message : 'Could not load reading');
      updateReadingStatus('Could not load reading.');
    }
  }

  async function loadNatalChart() {
    const chartStatus = document.getElementById('chart-status');
    const chartContent = document.getElementById('chart-content');
    const exportTextButton = document.getElementById('export-chart-text-btn') as HTMLButtonElement | null;
    const exportImageButton = document.getElementById('export-chart-image-btn') as HTMLButtonElement | null;
    if (chartStatus) chartStatus.style.display = 'block';
    try {
      const res = await authFetch('/v1/user/profile/natal-chart');
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data?.detail || 'Could not load chart');
      }
      const chart = await res.json();
      cachedChart = chart;
      const positions = Array.isArray(chart?.positions) ? chart.positions : [];
      const angles = Array.isArray(chart?.angles) ? chart.angles : [];
      const houseSystem = String(chart?.house_system || 'Placidus');

      // --- Render chart wheel on canvas ---
      const wheelCanvas = document.getElementById('chart-wheel-canvas') as HTMLCanvasElement | null;
      if (wheelCanvas) {
        const container = wheelCanvas.parentElement;
        const displaySize = Math.min(container?.clientWidth || 500, 500);
        const dpr = window.devicePixelRatio || 1;
        wheelCanvas.width = displaySize * dpr;
        wheelCanvas.height = displaySize * dpr;
        wheelCanvas.style.width = `${displaySize}px`;
        wheelCanvas.style.height = `${displaySize}px`;
        const wctx = wheelCanvas.getContext('2d');
        if (wctx) {
          // Dark background fill
          const bg = wctx.createRadialGradient(
            wheelCanvas.width / 2, wheelCanvas.height / 2, 0,
            wheelCanvas.width / 2, wheelCanvas.height / 2, wheelCanvas.width / 2,
          );
          bg.addColorStop(0, '#0a1228');
          bg.addColorStop(1, '#080510');
          wctx.fillStyle = bg;
          wctx.fillRect(0, 0, wheelCanvas.width, wheelCanvas.height);
          // Render wheel at 92% size for breathing room around sign labels
          const wheelSize = displaySize * dpr * 0.92;
          drawChartWheel(wctx, chart, wheelSize, (displaySize * dpr) / 2, (displaySize * dpr) / 2);

          // Compute planet screen positions for interactive click detection
          const wScale = wheelSize / 1100;
          const ascA = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');
          const ascLng = ascA ? Number(ascA.longitude || 0) : 0;
          const BASE_ORBIT_I = 340, ORBIT_STEP_I = 44, MIN_DEG_SEP_I = 12;
          const sPlanets = [...positions].map((pos: any) => {
            const lng = Number(pos?.longitude || zodiacDegrees(pos?.sign, pos?.degree));
            return { ...pos, _lng: lng };
          }).sort((a: any, b: any) => a._lng - b._lng);
          chartPlanetScreenPositions = sPlanets.map((p: any, idx: number) => {
            let depth = 0;
            for (let j = 0; j < idx; j++) {
              const diff = Math.abs(p._lng - sPlanets[j]._lng);
              if (Math.min(diff, 360 - diff) < MIN_DEG_SEP_I) depth++;
            }
            const orbitR = BASE_ORBIT_I + depth * ORBIT_STEP_I;
            const angle = Math.PI - ((p._lng - ascLng) * Math.PI) / 180;
            const cx = displaySize / 2 + Math.cos(angle) * orbitR * wScale;
            const cy = displaySize / 2 + Math.sin(angle) * orbitR * wScale;
            return {
              body: displayBody(p.body),
              sx: cx, sy: cy,
              sign: normalizeSign(p.sign),
              deg: Number(p.degree || 0).toFixed(1),
              house: p.house ? `House ${p.house}` : '',
              retro: Boolean(p.retrograde),
            };
          });
        }
      }

      // --- Build designed chart content ---
      if (chartContent) {
        const sun = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'sun');
        const moon = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'moon');
        const asc = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');
        const mc = angles.find((a: any) => {
          const n = String(a?.name || '').toLowerCase();
          return n === 'midheaven' || n === 'mc';
        });

        // Core signature hero row
        const heroItems = [sun, moon, asc].filter(Boolean).map((item: any) => {
          const isAngle = !!item?.name;
          const rawBody = isAngle ? 'ASC' : String(item?.body || '');
          const body = isAngle ? 'ASC' : displayBody(rawBody);
          const glyph = isAngle ? '' : (PLANET_GLYPHS[body] || PLANET_GLYPHS[rawBody] || '');
          const sign = normalizeSign(item?.sign);
          const signGlyph = SIGN_GLYPHS[sign] || '';
          const color = SIGN_COLORS[sign] || '#d6af72';
          const deg = Number(item?.degree || 0).toFixed(1);
          const planetTip = isAngle ? 'Rising sign \u2014 how you present to the world' : (PLANET_TIPS[body] || PLANET_TIPS[rawBody] || '');
          const signTip = SIGN_TIPS[sign] || '';
          return `<div class="chart-hero-item" data-tip="${escapeHtml(planetTip)}">
            <span class="chart-hero-glyph" style="color: ${color}">${escapeHtml(glyph || (isAngle ? 'ASC' : ''))}</span>
            <span class="chart-hero-label">${escapeHtml(body)}</span>
            <span class="chart-hero-detail" data-tip="${escapeHtml(signTip)}">${escapeHtml(deg)}\u00B0 ${escapeHtml(signGlyph)} ${escapeHtml(sign)}</span>
          </div>`;
        }).join('');

        // Placements grid
        const sortedPos = [...positions].sort(
          (a: any, b: any) => zodiacDegrees(a?.sign, a?.degree) - zodiacDegrees(b?.sign, b?.degree),
        );
        const placementItems = sortedPos.map((pos: any) => {
          const rawBody = String(pos?.body || '');
          const body = displayBody(rawBody);
          const glyph = PLANET_GLYPHS[body] || PLANET_GLYPHS[rawBody] || '';
          const sign = normalizeSign(pos?.sign);
          const signGlyph = SIGN_GLYPHS[sign] || '';
          const color = SIGN_COLORS[sign] || '#d6af72';
          const deg = Number(pos?.degree || 0).toFixed(1);
          const house = pos?.house ? `H${pos.house}` : '';
          const retro = Boolean(pos?.retrograde);
          const planetTip = PLANET_TIPS[body] || PLANET_TIPS[rawBody] || '';
          const signTip = SIGN_TIPS[sign] || '';
          const houseTip = pos?.house ? (HOUSE_TIPS[String(pos.house)] || '') : '';
          const retroTip = retro ? 'Retrograde \u2014 inward energy, review, and revision' : '';
          const dignity = getDignity(body, sign);
          const dignityInfo = dignity ? DIGNITY_LABELS[dignity] : null;
          const dignityHtml = dignityInfo
            ? ` <span class="chart-dignity chart-dignity-${dignity}" data-tip="${escapeHtml(dignityInfo.tip)}">${escapeHtml(dignityInfo.symbol)}</span>`
            : '';
          return `<div class="chart-placement" data-tip="${escapeHtml(planetTip)}">
            <span class="chart-placement-glyph" style="color: ${color}">${escapeHtml(glyph)}</span>
            <span class="chart-placement-name">${escapeHtml(body)}${retro ? ` <span class="chart-retro" data-tip="${escapeHtml(retroTip)}">\u211E</span>` : ''}${dignityHtml}</span>
            <span class="chart-placement-detail" data-tip="${escapeHtml(signTip)}${houseTip ? (signTip ? ' | ' : '') + escapeHtml(houseTip) : ''}">${escapeHtml(deg)}\u00B0 ${escapeHtml(signGlyph)} ${escapeHtml(sign)}${house ? ` \u00B7 ${escapeHtml(house)}` : ''}</span>
          </div>`;
        }).join('');

        // Aspects list
        const aspects = Array.isArray(chart?.aspects) ? chart.aspects : [];
        const filteredAspects = aspects
          .filter((a: any) => String(a?.significance || '').toLowerCase() !== 'minor')
          .sort((a: any, b: any) => {
            const sigA = String(a?.significance || '').toLowerCase() === 'major' ? 0 : 1;
            const sigB = String(b?.significance || '').toLowerCase() === 'major' ? 0 : 1;
            if (sigA !== sigB) return sigA - sigB;
            return Number(a?.orb_degrees || a?.orb || 0) - Number(b?.orb_degrees || b?.orb || 0);
          });
        const aspectItems = filteredAspects.map((asp: any) => {
          const type = String(asp?.type || asp?.aspect_type || '').toLowerCase();
          const glyph = ASPECT_GLYPHS[type] || '';
          const color = CHART_ASPECT_COLORS[type] || '#d6af72';
          const body1 = displayBody(asp?.body1);
          const body2 = displayBody(asp?.body2);
          const orb = Number(asp?.orb_degrees || asp?.orb || 0).toFixed(1);
          const applying = asp?.applying !== false ? 'applying' : 'separating';
          const aspectTip = ASPECT_TIPS[type] || '';
          const applyTip = applying === 'applying' ? 'Building toward exact alignment' : 'Moving past exact alignment';
          return `<div class="chart-aspect" data-tip="${escapeHtml(aspectTip)}">
            <span class="chart-aspect-glyph" style="color: ${color}">${escapeHtml(glyph)}</span>
            <span class="chart-aspect-bodies">${escapeHtml(body1)} ${escapeHtml(glyph)} ${escapeHtml(body2)}</span>
            <span class="chart-aspect-detail" data-tip="${escapeHtml(applyTip)}">${escapeHtml(orb)}\u00B0 \u00B7 ${escapeHtml(applying)}</span>
          </div>`;
        }).join('');
        const aspectsHtml = filteredAspects.length > 0
          ? `<div class="chart-aspects-label" data-tip="Angular relationships between planets \u2014 the conversations happening in your chart">Aspects</div><div class="chart-aspects">${aspectItems}</div>`
          : '';

        // --- Chart Details: element/modality/polarity breakdown ---
        const ELEMENT_COLORS: Record<string, string> = {
          Fire: '#ff8b7b', Earth: '#bce68f', Air: '#f1ea86', Water: '#9fd2ff',
        };
        const MODALITY_COLORS: Record<string, string> = {
          Cardinal: '#d6af72', Fixed: '#b9a3ff', Mutable: '#90d0ff',
        };
        const elementCounts: Record<string, number> = { Fire: 0, Earth: 0, Air: 0, Water: 0 };
        const modalityCounts: Record<string, number> = { Cardinal: 0, Fixed: 0, Mutable: 0 };
        const signCounts: Record<string, number> = {};

        for (const pos of positions) {
          const sign = normalizeSign(pos?.sign);
          const el = ELEMENT_MAP[sign];
          const mod = MODALITY_MAP[sign];
          if (el) elementCounts[el]++;
          if (mod) modalityCounts[mod]++;
          signCounts[sign] = (signCounts[sign] || 0) + 1;
        }

        const totalPlanets = positions.length || 1;

        function buildBarRow(label: string, count: number, max: number, color: string, tip: string): string {
          const pct = Math.round((count / max) * 100);
          return `<div class="chart-bar-row" data-tip="${escapeHtml(tip)}">
            <span class="chart-bar-label">${escapeHtml(label)}</span>
            <span class="chart-bar-track"><span class="chart-bar-fill" style="width: ${pct}%; background: ${color}"></span></span>
            <span class="chart-bar-count">${count}</span>
          </div>`;
        }

        const elementBars = ['Fire', 'Earth', 'Air', 'Water']
          .map((el) => buildBarRow(el, elementCounts[el], totalPlanets, ELEMENT_COLORS[el], ELEMENT_TIPS[el] || '')).join('');

        const modalityBars = ['Cardinal', 'Fixed', 'Mutable']
          .map((mod) => buildBarRow(mod, modalityCounts[mod], totalPlanets, MODALITY_COLORS[mod], MODALITY_TIPS[mod] || '')).join('');

        // Polarity
        const masculine = elementCounts['Fire'] + elementCounts['Air'];
        const feminine = elementCounts['Earth'] + elementCounts['Water'];
        const polarityLabel = masculine > feminine ? 'Yang-dominant' : feminine > masculine ? 'Yin-dominant' : 'Balanced';
        const polarityHtml = `<div class="chart-polarity" data-tip="Yang (Fire &amp; Air): outward, active expression. Yin (Earth &amp; Water): inward, receptive reflection.">
          <span class="chart-polarity-label">Polarity</span>
          <span class="chart-polarity-bar">
            <span class="chart-polarity-fill chart-polarity-yang" style="width: ${Math.round((masculine / totalPlanets) * 100)}%" data-tip="Yang (Fire &amp; Air): ${masculine}"></span>
            <span class="chart-polarity-fill chart-polarity-yin" style="width: ${Math.round((feminine / totalPlanets) * 100)}%" data-tip="Yin (Earth &amp; Water): ${feminine}"></span>
          </span>
          <span class="chart-polarity-value">${escapeHtml(polarityLabel)}</span>
        </div>`;

        // Stelliums (3+ planets in same sign)
        const stelliums = Object.entries(signCounts)
          .filter(([, count]) => count >= 3)
          .sort((a, b) => b[1] - a[1]);
        const stelliumHtml = stelliums.length > 0
          ? `<div class="chart-stelliums" data-tip="A stellium is 3+ planets concentrated in one sign \u2014 intensified focus in that area of life"><span class="chart-detail-sublabel">Stelliums</span>${stelliums.map(
              ([sign, count]) => `<span class="chart-stellium-tag" style="color: ${SIGN_COLORS[sign] || '#d6af72'}" data-tip="${escapeHtml(SIGN_TIPS[sign] || '')}">${escapeHtml(sign)} (${count})</span>`
            ).join('')}</div>`
          : '';

        // Aspect type breakdown
        const aspectTypeCounts: Record<string, number> = {};
        for (const asp of filteredAspects) {
          const type = String(asp?.type || asp?.aspect_type || '').toLowerCase();
          if (type) aspectTypeCounts[type] = (aspectTypeCounts[type] || 0) + 1;
        }
        const aspectSummaryItems = ['conjunction', 'opposition', 'trine', 'square', 'sextile']
          .filter((t) => aspectTypeCounts[t])
          .map((t) => {
            const glyph = ASPECT_GLYPHS[t] || '';
            const color = CHART_ASPECT_COLORS[t] || '#d6af72';
            const label = t.charAt(0).toUpperCase() + t.slice(1);
            return `<span class="chart-aspect-stat" style="color: ${color}" data-tip="${escapeHtml(ASPECT_TIPS[t] || '')}">${escapeHtml(glyph)} ${aspectTypeCounts[t]} ${escapeHtml(label)}${aspectTypeCounts[t] > 1 ? 's' : ''}</span>`;
          }).join('');
        const aspectSummaryHtml = aspectSummaryItems
          ? `<div class="chart-aspect-summary"><span class="chart-detail-sublabel" data-tip="Count of each aspect type in your chart \u2014 reveals the dominant themes and tensions">Aspect Breakdown</span><div class="chart-aspect-stats">${aspectSummaryItems}</div></div>`
          : '';

        // Retrograde count
        const retroCount = positions.filter((p: any) => Boolean(p?.retrograde)).length;
        const retroHtml = retroCount > 0
          ? `<div class="chart-retro-summary" data-tip="Retrograde planets appear to move backward \u2014 their energy turns inward for review and revision"><span class="chart-detail-sublabel">Retrograde</span><span class="chart-retro-value">${retroCount} planet${retroCount > 1 ? 's' : ''} in retrograde</span></div>`
          : '';

        // Chart Ruler
        const ascSign = asc ? normalizeSign(asc.sign) : '';
        const chartRulerName = ascSign ? (SIGN_RULERS[ascSign] || '') : '';
        const chartRulerPos = chartRulerName ? positions.find((p: any) => displayBody(p?.body) === chartRulerName) : null;
        const chartRulerHtml = chartRulerPos ? (() => {
          const rSign = normalizeSign(chartRulerPos.sign);
          const rDeg = Number(chartRulerPos.degree || 0).toFixed(1);
          const rHouse = chartRulerPos.house ? `H${chartRulerPos.house}` : '';
          const rGlyph = PLANET_GLYPHS[chartRulerName] || '';
          const rColor = SIGN_COLORS[rSign] || '#d6af72';
          const rSignGlyph = SIGN_GLYPHS[rSign] || '';
          return `<div class="chart-highlight-card" data-tip="The chart ruler is the planet that rules the Ascendant sign \u2014 it colors your entire life approach">
            <span class="chart-detail-sublabel">Chart Ruler</span>
            <span class="chart-highlight-value"><span style="color: ${rColor}">${escapeHtml(rGlyph)}</span> ${escapeHtml(chartRulerName)}</span>
            <span class="chart-highlight-detail">${escapeHtml(rDeg)}\u00B0 ${escapeHtml(rSignGlyph)} ${escapeHtml(rSign)}${rHouse ? ` \u00B7 ${escapeHtml(rHouse)}` : ''}</span>
          </div>`;
        })() : '';

        // House Cusps Table
        const houseCusps = Array.isArray(chart?.house_cusps) ? chart.house_cusps : [];
        const houseCuspsHtml = houseCusps.length === 12 ? (() => {
          const rows = houseCusps.map((cusp: number, i: number) => {
            const houseNum = i + 1;
            const totalDeg = ((cusp % 360) + 360) % 360;
            const signIdx = Math.floor(totalDeg / 30);
            const sign = SIGN_ORDER[signIdx] || '';
            const deg = (totalDeg % 30).toFixed(1);
            const signGlyph = SIGN_GLYPHS[sign] || '';
            const color = SIGN_COLORS[sign] || '#d6af72';
            const tip = HOUSE_TIPS[String(houseNum)] || '';
            return `<div class="chart-cusp-row" data-tip="${escapeHtml(tip)}">
              <span class="chart-cusp-num">H${houseNum}</span>
              <span class="chart-cusp-deg" style="color: ${color}">${escapeHtml(deg)}\u00B0 ${escapeHtml(signGlyph)} ${escapeHtml(sign)}</span>
            </div>`;
          }).join('');
          return `<div class="chart-cusps-section">
            <span class="chart-detail-sublabel" data-tip="The zodiac degree where each house begins \u2014 defines the areas of life each sign governs for you">House Cusps</span>
            <div class="chart-cusps-grid">${rows}</div>
          </div>`;
        })() : '';

        // Dominant Planet Analysis
        const aspectCountPerPlanet: Record<string, number> = {};
        for (const asp of filteredAspects) {
          const b1 = displayBody(asp?.body1);
          const b2 = displayBody(asp?.body2);
          aspectCountPerPlanet[b1] = (aspectCountPerPlanet[b1] || 0) + 1;
          aspectCountPerPlanet[b2] = (aspectCountPerPlanet[b2] || 0) + 1;
        }
        // Weight: aspects + chart ruler bonus + Sun ruler bonus + Moon ruler bonus
        const sunSign = sun ? normalizeSign(sun.sign) : '';
        const moonSign = moon ? normalizeSign(moon.sign) : '';
        const sunRuler = sunSign ? (SIGN_RULERS[sunSign] || '') : '';
        const moonRuler = moonSign ? (SIGN_RULERS[moonSign] || '') : '';
        let dominantPlanet = '';
        let dominantScore = 0;
        for (const pos of positions) {
          const body = displayBody(pos?.body);
          let score = aspectCountPerPlanet[body] || 0;
          if (body === chartRulerName) score += 3;
          if (body === sunRuler) score += 2;
          if (body === moonRuler) score += 2;
          const dig = getDignity(body, normalizeSign(pos?.sign));
          if (dig === 'domicile' || dig === 'exaltation') score += 1;
          if (score > dominantScore) { dominantScore = score; dominantPlanet = body; }
        }
        const dominantPos = dominantPlanet ? positions.find((p: any) => displayBody(p?.body) === dominantPlanet) : null;
        const dominantHtml = dominantPos ? (() => {
          const dSign = normalizeSign(dominantPos.sign);
          const dGlyph = PLANET_GLYPHS[dominantPlanet] || '';
          const dColor = SIGN_COLORS[dSign] || '#d6af72';
          const reasons: string[] = [];
          if (dominantPlanet === chartRulerName) reasons.push('chart ruler');
          if (dominantPlanet === sunRuler) reasons.push('Sun ruler');
          if (dominantPlanet === moonRuler) reasons.push('Moon ruler');
          const aspCount = aspectCountPerPlanet[dominantPlanet] || 0;
          if (aspCount > 0) reasons.push(`${aspCount} aspects`);
          return `<div class="chart-highlight-card" data-tip="Most influential planet based on aspects, rulerships, and dignities">
            <span class="chart-detail-sublabel">Dominant Planet</span>
            <span class="chart-highlight-value"><span style="color: ${dColor}">${escapeHtml(dGlyph)}</span> ${escapeHtml(dominantPlanet)}</span>
            ${reasons.length ? `<span class="chart-highlight-detail">${escapeHtml(reasons.join(', '))}</span>` : ''}
          </div>`;
        })() : '';

        // Chart Pattern
        const planetLongitudes = positions.map((p: any) => Number(p?.longitude || zodiacDegrees(p?.sign, p?.degree)));
        const chartPattern = detectChartPattern(planetLongitudes);
        const patternHtml = chartPattern.name !== 'Unknown'
          ? `<div class="chart-highlight-card" data-tip="${escapeHtml(chartPattern.description)}">
              <span class="chart-detail-sublabel">Chart Shape</span>
              <span class="chart-highlight-value">${escapeHtml(chartPattern.name)}</span>
            </div>`
          : '';

        // Aspect Matrix Grid
        const matrixBodies = positions.map((p: any) => displayBody(p?.body));
        const aspectLookup: Record<string, { type: string; glyph: string; color: string }> = {};
        for (const asp of filteredAspects) {
          const b1 = displayBody(asp?.body1);
          const b2 = displayBody(asp?.body2);
          const type = String(asp?.type || asp?.aspect_type || '').toLowerCase();
          const info = { type, glyph: ASPECT_GLYPHS[type] || '', color: CHART_ASPECT_COLORS[type] || '#d6af72' };
          aspectLookup[`${b1}|${b2}`] = info;
          aspectLookup[`${b2}|${b1}`] = info;
        }
        const matrixHeaderCells = matrixBodies.map((b) => {
          const g = PLANET_GLYPHS[b] || '';
          return `<span class="matrix-hdr" data-tip="${escapeHtml(PLANET_TIPS[b] || '')}">${escapeHtml(g || bodyAbbreviation(b))}</span>`;
        }).join('');
        const matrixRows = matrixBodies.map((rowBody, ri) => {
          const rowGlyph = PLANET_GLYPHS[rowBody] || '';
          const cells = matrixBodies.map((colBody, ci) => {
            if (ri === ci) return '<span class="matrix-cell matrix-diag"></span>';
            const key = `${rowBody}|${colBody}`;
            const asp = aspectLookup[key];
            if (!asp) return '<span class="matrix-cell"></span>';
            return `<span class="matrix-cell" style="color: ${asp.color}" data-tip="${escapeHtml(ASPECT_TIPS[asp.type] || asp.type)}">${escapeHtml(asp.glyph)}</span>`;
          }).join('');
          return `<div class="matrix-row"><span class="matrix-hdr" data-tip="${escapeHtml(PLANET_TIPS[rowBody] || '')}">${escapeHtml(rowGlyph || bodyAbbreviation(rowBody))}</span>${cells}</div>`;
        }).join('');
        const aspectMatrixHtml = `
          <div class="chart-matrix-section">
            <span class="chart-detail-sublabel" data-tip="A grid showing every aspect between planets at a glance \u2014 rows and columns are planets, cells show the aspect type">Aspect Matrix</span>
            <div class="chart-matrix">
              <div class="matrix-row matrix-header-row"><span class="matrix-hdr"></span>${matrixHeaderCells}</div>
              ${matrixRows}
            </div>
          </div>`;

        const chartDetailsHtml = `
          <div class="chart-details-label" data-tip="A breakdown of your chart\u2019s elemental, modal, and planetary signatures">Chart Details</div>
          <div class="chart-details">
            <div class="chart-details-grid">
              <div class="chart-detail-group">
                <span class="chart-detail-sublabel" data-tip="The four classical elements show your temperament and energy style">Elements</span>
                ${elementBars}
              </div>
              <div class="chart-detail-group">
                <span class="chart-detail-sublabel" data-tip="Cardinal initiates, Fixed sustains, Mutable adapts \u2014 your action style">Modalities</span>
                ${modalityBars}
              </div>
            </div>
            ${polarityHtml}
            <div class="chart-details-highlights">
              ${chartRulerHtml}${dominantHtml}${patternHtml}
            </div>
            ${stelliumHtml ? `<div class="chart-details-secondary">${stelliumHtml}</div>` : ''}
            <div class="chart-details-secondary">${aspectSummaryHtml}${retroHtml}</div>
            ${houseCuspsHtml}
            ${aspectMatrixHtml}
          </div>
        `;

        // Footer line
        const footerParts: string[] = [];
        if (asc) footerParts.push(`Asc ${Number(asc.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(asc.sign)}`);
        if (mc) footerParts.push(`MC ${Number(mc.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(mc.sign)}`);
        footerParts.push(houseSystem);

        chartContent.innerHTML = `
          <div class="chart-hero chart-fadein" style="animation-delay: 0s">${heroItems}</div>
          <div class="chart-placements chart-fadein" style="animation-delay: 0.08s">${placementItems}</div>
          <div class="chart-fadein" style="animation-delay: 0.16s">${aspectsHtml}</div>
          <div class="chart-fadein" style="animation-delay: 0.24s">${chartDetailsHtml}</div>
          <div class="chart-detail-footer chart-fadein" style="animation-delay: 0.32s">${escapeHtml(footerParts.join('  \u00B7  '))}</div>
        `;
      }
      if (chartStatus) chartStatus.style.display = 'none';
      if (exportTextButton) exportTextButton.style.display = 'inline-flex';
      if (exportImageButton) exportImageButton.style.display = 'inline-flex';
      // Load transit overlay now that cachedChart is available
      void loadTransitOverlay();
    } catch (err) {
      if (exportTextButton) exportTextButton.style.display = 'none';
      if (exportImageButton) exportImageButton.style.display = 'none';
      if (chartStatus) {
        chartStatus.style.display = 'block';
        chartStatus.className = 'reading-status';
        chartStatus.textContent = err instanceof Error ? err.message : 'Could not load natal chart';
      }
    }
  }

  function natalChartText(chart: Record<string, unknown>): string {
    const data = chart as any;
    const positions = Array.isArray(data.positions) ? (data.positions as any[]) : [];
    const angles = Array.isArray(data.angles) ? (data.angles as any[]) : [];
    const aspects = Array.isArray(data.aspects) ? (data.aspects as any[]) : [];
    const houseCuspsArr = Array.isArray(data.house_cusps) ? (data.house_cusps as number[]) : [];
    const houseSystem = String(data.house_system || 'Placidus');
    const lines: string[] = [];
    lines.push('VOIDWIRE \u2014 Natal Chart');
    lines.push(`Generated: ${new Date().toISOString()}`);
    lines.push('');

    // Core Signature
    const sun = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'sun');
    const moon = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'moon');
    const asc = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');
    if (sun || moon || asc) {
      lines.push('Core Signature:');
      if (sun) lines.push(`  Sun: ${Number(sun.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(sun.sign)}${sun.house ? ` (House ${sun.house})` : ''}`);
      if (moon) lines.push(`  Moon: ${Number(moon.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(moon.sign)}${moon.house ? ` (House ${moon.house})` : ''}`);
      if (asc) lines.push(`  Ascendant: ${Number(asc.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(asc.sign)}`);
      lines.push('');
    }

    // Placements with dignities
    lines.push('Placements:');
    const sortedTextPos = [...positions].sort((a: any, b: any) => zodiacDegrees(a?.sign, a?.degree) - zodiacDegrees(b?.sign, b?.degree));
    for (const pos of sortedTextPos) {
      const body = displayBody(pos?.body);
      const degree = Number(pos?.degree || 0).toFixed(1);
      const sign = normalizeSign(pos?.sign);
      const house = pos?.house ? `House ${pos.house}` : '';
      const retro = Boolean(pos?.retrograde) ? ' (R)' : '';
      const dignity = getDignity(body, sign);
      const digLabel = dignity ? ` [${DIGNITY_LABELS[dignity]?.label || ''}]` : '';
      lines.push(`  ${body}: ${degree}\u00B0 ${sign}${house ? ` \u00B7 ${house}` : ''}${retro}${digLabel}`);
    }

    // Angles
    if (angles.length > 0) {
      lines.push('');
      lines.push('Angles:');
      for (const angle of angles) {
        lines.push(`  ${String(angle?.name || '')}: ${Number(angle?.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(angle?.sign)}`);
      }
    }

    // Elements & Modalities
    const elCounts: Record<string, number> = { Fire: 0, Earth: 0, Air: 0, Water: 0 };
    const modCounts: Record<string, number> = { Cardinal: 0, Fixed: 0, Mutable: 0 };
    for (const pos of positions) {
      const s = normalizeSign(pos?.sign);
      const el = ELEMENT_MAP[s]; if (el) elCounts[el]++;
      const mod = MODALITY_MAP[s]; if (mod) modCounts[mod]++;
    }
    lines.push('');
    lines.push(`Elements: Fire ${elCounts.Fire}, Earth ${elCounts.Earth}, Air ${elCounts.Air}, Water ${elCounts.Water}`);
    lines.push(`Modalities: Cardinal ${modCounts.Cardinal}, Fixed ${modCounts.Fixed}, Mutable ${modCounts.Mutable}`);

    // Chart Ruler
    const ascSign = asc ? normalizeSign(asc.sign) : '';
    const rulerName = ascSign ? (SIGN_RULERS[ascSign] || '') : '';
    if (rulerName) {
      const rulerPos = positions.find((p: any) => displayBody(p?.body) === rulerName);
      if (rulerPos) {
        lines.push(`Chart Ruler: ${rulerName} in ${Number(rulerPos.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(rulerPos.sign)}${rulerPos.house ? ` (House ${rulerPos.house})` : ''}`);
      }
    }

    // Chart Pattern
    const longs = positions.map((p: any) => Number(p?.longitude || zodiacDegrees(p?.sign, p?.degree)));
    const pattern = detectChartPattern(longs);
    if (pattern.name !== 'Unknown') {
      lines.push(`Chart Shape: ${pattern.name}`);
    }

    // Aspects
    const filtAsp = aspects.filter((a: any) => String(a?.significance || '').toLowerCase() !== 'minor');
    if (filtAsp.length > 0) {
      lines.push('');
      lines.push('Aspects:');
      for (const asp of filtAsp) {
        const type = String(asp?.type || asp?.aspect_type || '');
        const b1 = displayBody(asp?.body1);
        const b2 = displayBody(asp?.body2);
        const orb = Number(asp?.orb_degrees || asp?.orb || 0).toFixed(1);
        const applying = asp?.applying !== false ? 'applying' : 'separating';
        lines.push(`  ${b1} ${type} ${b2} (${orb}\u00B0, ${applying})`);
      }
    }

    // House Cusps
    if (houseCuspsArr.length === 12) {
      lines.push('');
      lines.push(`House Cusps (${houseSystem}):`);
      for (let i = 0; i < 12; i++) {
        const totalDeg = ((houseCuspsArr[i] % 360) + 360) % 360;
        const signIdx = Math.floor(totalDeg / 30);
        const sign = SIGN_ORDER[signIdx] || '';
        const deg = (totalDeg % 30).toFixed(1);
        lines.push(`  House ${i + 1}: ${deg}\u00B0 ${sign}`);
      }
    }

    lines.push('');
    lines.push(`\u2014 ${chartBrandDomain}`);
    return lines.join('\n');
  }

  async function ensureFontsLoaded() {
    await Promise.all([
      document.fonts.load('400 48px "EB Garamond"'),
      document.fonts.load('600 48px "EB Garamond"'),
      document.fonts.load('500 48px "Inter"'),
      document.fonts.load('600 48px "Inter"'),
      document.fonts.load('400 48px "JetBrains Mono"'),
    ]);
  }

  function drawChartWheel(ctx: CanvasRenderingContext2D, chart: any, size: number, cx: number, cy: number) {
    const scale = size / 1100;
    const positions = Array.isArray(chart.positions) ? (chart.positions as any[]) : [];
    const angles = Array.isArray(chart.angles) ? (chart.angles as any[]) : [];
    const aspects = Array.isArray(chart.aspects) ? (chart.aspects as any[]) : [];
    const houseCusps = Array.isArray(chart.house_cusps) ? (chart.house_cusps as number[]) : [];

    const R_OUTER = 460, R_SIGN_INNER = 390, R_INNER = 255;
    const BRASS = '#d6af72';

    const ascAngle = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');
    const ascLong = ascAngle ? Number(ascAngle.longitude || 0) : 0;

    function longToAngle(longitude: number): number {
      return Math.PI - ((longitude - ascLong) * Math.PI) / 180;
    }

    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);

    // --- Layer 4: Sacred geometry ---
    ctx.save();
    ctx.strokeStyle = 'rgba(214, 175, 114, 0.055)';
    ctx.lineWidth = 1;
    for (let k = 0; k < 2; k++) {
      ctx.beginPath();
      for (let i = 0; i < 3; i++) {
        const a = ((i * 120 + k * 60) * Math.PI) / 180;
        if (i === 0) ctx.moveTo(Math.cos(a) * R_INNER * 0.9, Math.sin(a) * R_INNER * 0.9);
        else ctx.lineTo(Math.cos(a) * R_INNER * 0.9, Math.sin(a) * R_INNER * 0.9);
      }
      ctx.closePath();
      ctx.stroke();
    }
    const phi = 1.618033988749;
    for (let i = 1; i <= 4; i++) {
      const r = R_INNER * 0.15 * Math.pow(phi, i);
      if (r < R_OUTER) { ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke(); }
    }
    for (let deg = 0; deg < 360; deg += 15) {
      const a = (deg * Math.PI) / 180;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a) * R_INNER * 0.3, Math.sin(a) * R_INNER * 0.3);
      ctx.lineTo(Math.cos(a) * R_INNER * 0.85, Math.sin(a) * R_INNER * 0.85);
      ctx.stroke();
    }
    ctx.restore();

    // --- Layer 5: Wheel structure ---
    ctx.save();

    ctx.strokeStyle = 'rgba(214, 175, 114, 0.5)';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.arc(0, 0, R_OUTER, 0, Math.PI * 2); ctx.stroke();

    ctx.strokeStyle = 'rgba(214, 175, 114, 0.35)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(0, 0, R_SIGN_INNER, 0, Math.PI * 2); ctx.stroke();

    ctx.strokeStyle = 'rgba(214, 175, 114, 0.4)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0, 0, R_INNER, 0, Math.PI * 2); ctx.stroke();

    for (let i = 0; i < 12; i++) {
      const signLongStart = i * 30;
      const startA = longToAngle(signLongStart);
      const endA = longToAngle(signLongStart + 30);
      const sign = SIGN_ORDER[i];
      const signColor = SIGN_COLORS[sign] || '#9aa6c0';

      ctx.beginPath();
      ctx.arc(0, 0, R_OUTER, startA, endA, true);
      ctx.arc(0, 0, R_SIGN_INNER, endA, startA, false);
      ctx.closePath();
      ctx.fillStyle = `${signColor}15`;
      ctx.fill();

      ctx.strokeStyle = 'rgba(214, 175, 114, 0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(startA) * R_SIGN_INNER, Math.sin(startA) * R_SIGN_INNER);
      ctx.lineTo(Math.cos(startA) * R_OUTER, Math.sin(startA) * R_OUTER);
      ctx.stroke();

      const midA = longToAngle(signLongStart + 15);
      const glyphR = (R_OUTER + R_SIGN_INNER) / 2;
      ctx.fillStyle = signColor;
      ctx.font = '400 34px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(SIGN_GLYPHS[sign] || '', Math.cos(midA) * glyphR, Math.sin(midA) * glyphR);
    }

    for (let deg = 0; deg < 360; deg++) {
      const a = longToAngle(deg);
      const isMaj = deg % 10 === 0, isMin = deg % 5 === 0;
      const tick = isMaj ? 8 : isMin ? 5 : 2;
      ctx.strokeStyle = isMaj ? 'rgba(214, 175, 114, 0.3)' : 'rgba(214, 175, 114, 0.12)';
      ctx.lineWidth = isMaj ? 1.2 : 0.6;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a) * R_OUTER, Math.sin(a) * R_OUTER);
      ctx.lineTo(Math.cos(a) * (R_OUTER + tick), Math.sin(a) * (R_OUTER + tick));
      ctx.stroke();
    }

    if (houseCusps.length === 12) {
      for (let i = 0; i < 12; i++) {
        const a = longToAngle(houseCusps[i]);
        const isCard = i === 0 || i === 3 || i === 6 || i === 9;
        ctx.strokeStyle = isCard ? 'rgba(214, 175, 114, 0.4)' : 'rgba(214, 175, 114, 0.15)';
        ctx.lineWidth = isCard ? 1.8 : 0.8;
        const outerR = isCard ? R_OUTER + 12 : R_SIGN_INNER;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(a) * outerR, Math.sin(a) * outerR);
        ctx.stroke();
      }
    }

    // --- Layer 6: Aspect web ---
    const posLongMap: Record<string, number> = {};
    for (const pos of positions) {
      const body = String(pos?.body || '').toLowerCase();
      posLongMap[body] = Number(pos?.longitude || zodiacDegrees(pos?.sign, pos?.degree));
    }

    for (const asp of aspects) {
      const type = String(asp?.type || asp?.aspect_type || '').toLowerCase();
      const sig = String(asp?.significance || '').toLowerCase();
      if (sig === 'minor') continue;
      const color = CHART_ASPECT_COLORS[type];
      if (!color) continue;
      const body1Long = posLongMap[String(asp?.body1 || '').toLowerCase()];
      const body2Long = posLongMap[String(asp?.body2 || '').toLowerCase()];
      if (body1Long == null || body2Long == null) continue;

      const a1 = longToAngle(body1Long), a2 = longToAngle(body2Long);
      const webR = R_INNER - 10;
      const orb = Number(asp?.orb_degrees || asp?.orb || 0);
      const opacity = Math.max(0.15, 0.7 * (1 - orb / 10));

      ctx.strokeStyle = color;
      ctx.globalAlpha = opacity;
      ctx.lineWidth = sig === 'major' ? 1.8 : 1;
      ctx.setLineDash(asp?.applying === false ? [6, 4] : []);

      ctx.beginPath();
      ctx.moveTo(Math.cos(a1) * webR, Math.sin(a1) * webR);
      ctx.lineTo(Math.cos(a2) * webR, Math.sin(a2) * webR);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.setLineDash([]);

    // --- Layer 7: Planet markers (collision avoidance with fan-out) ---
    const MARKER_R = 20;          // circle radius
    const GLYPH_PX = 28;         // glyph font size
    const BASE_ORBIT = 340;
    const ORBIT_STEP = 44;       // radial offset per stagger level
    const MIN_DEG_SEP = 12;      // minimum degrees before fan-out triggers

    const planetData = positions.map((pos: any) => {
      const lng = Number(pos?.longitude || zodiacDegrees(pos?.sign, pos?.degree));
      return { ...pos, _longitude: lng, _angle: longToAngle(lng) };
    }).sort((a: any, b: any) => a._longitude - b._longitude);

    // Assign radial orbits: planets within MIN_DEG_SEP of a prior planet
    // get pushed outward in alternating directions to fan out clusters.
    const displayData = planetData.map((p: any, idx: number) => {
      let clusterDepth = 0;
      for (let j = 0; j < idx; j++) {
        const diff = Math.abs(p._longitude - planetData[j]._longitude);
        if (Math.min(diff, 360 - diff) < MIN_DEG_SEP) clusterDepth++;
      }
      return { ...p, _orbitR: BASE_ORBIT + clusterDepth * ORBIT_STEP };
    });

    for (const pos of displayData) {
      const angle = pos._angle;
      const orbitR = pos._orbitR;
      const x = Math.cos(angle) * orbitR;
      const y = Math.sin(angle) * orbitR;
      const sign = normalizeSign(pos.sign);
      const color = SIGN_COLORS[sign] || '#d6af72';
      const rawBody = String(pos.body || '');
      const body = displayBody(rawBody);
      const glyph = PLANET_GLYPHS[body] || PLANET_GLYPHS[rawBody] || '';
      const retro = Boolean(pos.retrograde);

      // Tick line from inner ring to marker
      ctx.strokeStyle = `${color}50`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(Math.cos(angle) * R_INNER, Math.sin(angle) * R_INNER);
      ctx.lineTo(x, y);
      ctx.stroke();

      // Soft glow behind marker
      const glowG = ctx.createRadialGradient(x, y, 0, x, y, MARKER_R + 10);
      glowG.addColorStop(0, `${color}28`);
      glowG.addColorStop(1, `${color}00`);
      ctx.fillStyle = glowG;
      ctx.beginPath(); ctx.arc(x, y, MARKER_R + 10, 0, Math.PI * 2); ctx.fill();

      // Circle background + border
      ctx.fillStyle = '#080c16';
      ctx.beginPath(); ctx.arc(x, y, MARKER_R, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(x, y, MARKER_R, 0, Math.PI * 2); ctx.stroke();

      // Planetary glyph — fills most of the circle
      ctx.fillStyle = color;
      ctx.font = `400 ${GLYPH_PX}px "Segoe UI Symbol", "EB Garamond", Georgia, serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(glyph, x, y + 1);

      // Retrograde indicator — warm red dot + R badge
      if (retro) {
        const rx = x + MARKER_R + 6, ry = y - MARKER_R + 2;
        ctx.fillStyle = '#c04040';
        ctx.beginPath(); ctx.arc(rx, ry, 9, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#f0e8e0';
        ctx.font = '700 13px "Inter", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('R', rx, ry);
      }
    }

    // --- Layer 8: Angle markers (ASC/MC/DSC/IC) ---
    const angleMarkers = [
      { key: 'ascendant', abbr: 'ASC' },
      { key: 'midheaven', abbr: 'MC' },
      { key: 'descendant', abbr: 'DSC' },
      { key: 'imum coeli', abbr: 'IC' },
    ];
    for (const am of angleMarkers) {
      const found = angles.find((a: any) => String(a?.name || '').toLowerCase() === am.key);
      if (!found) continue;
      const lng = Number(found.longitude || zodiacDegrees(found.sign, found.degree));
      const a = longToAngle(lng);
      const isMain = am.abbr === 'ASC' || am.abbr === 'MC';

      ctx.strokeStyle = isMain ? `${BRASS}70` : `${BRASS}35`;
      ctx.lineWidth = isMain ? 1.8 : 1;
      ctx.setLineDash(isMain ? [] : [8, 6]);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(Math.cos(a) * R_SIGN_INNER, Math.sin(a) * R_SIGN_INNER);
      ctx.stroke();
      ctx.setLineDash([]);

      const lblR = R_INNER - 30;
      ctx.fillStyle = BRASS;
      ctx.font = `600 ${isMain ? 18 : 14}px "Inter", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(am.abbr, Math.cos(a) * lblR, Math.sin(a) * lblR);
    }

    ctx.restore();

    // --- Layer 9: Sign labels outside outer rim ---
    ctx.save();
    for (let i = 0; i < 12; i++) {
      const midA = longToAngle(i * 30 + 15);
      const labelR = R_OUTER + 72;
      const sign = SIGN_ORDER[i];
      ctx.fillStyle = SIGN_COLORS[sign] || '#9aa6c0';
      ctx.font = '600 22px "Inter", sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(sign.slice(0, 3).toUpperCase(), Math.cos(midA) * labelR, Math.sin(midA) * labelR);
    }
    ctx.restore();

    ctx.restore();
  }

  async function loadTransitOverlay() {
    if (!cachedChart || !hasProfile) return;
    const overlay = document.getElementById('transit-overlay');
    const transitContent = document.getElementById('transit-content');
    const transitCanvas = document.getElementById('transit-wheel-canvas') as HTMLCanvasElement | null;
    if (!overlay || !transitCanvas) return;
    try {
      const ephRes = await authFetch('/v1/ephemeris/today');
      if (!ephRes.ok) return;
      const ephData = await ephRes.json();
      // Ephemeris API returns positions as a dict keyed by body name, convert to array
      const rawPositions = ephData?.positions;
      const transitPositions: any[] = rawPositions && typeof rawPositions === 'object' && !Array.isArray(rawPositions)
        ? Object.entries(rawPositions).map(([body, data]: [string, any]) => ({ body, ...data }))
        : Array.isArray(rawPositions) ? rawPositions : [];
      const transitAspects = Array.isArray(ephData?.aspects) ? ephData.aspects : [];
      if (transitPositions.length === 0) return;
      overlay.style.display = 'block';

      // Draw natal wheel with transit overlay
      const natalChart = cachedChart as any;
      const container = transitCanvas.parentElement;
      const displaySize = Math.min(container?.clientWidth || 500, 500);
      const dpr = window.devicePixelRatio || 1;
      transitCanvas.width = displaySize * dpr;
      transitCanvas.height = displaySize * dpr;
      transitCanvas.style.width = `${displaySize}px`;
      transitCanvas.style.height = `${displaySize}px`;
      const ctx = transitCanvas.getContext('2d');
      if (!ctx) return;

      // Background
      const bg = ctx.createRadialGradient(
        transitCanvas.width / 2, transitCanvas.height / 2, 0,
        transitCanvas.width / 2, transitCanvas.height / 2, transitCanvas.width / 2,
      );
      bg.addColorStop(0, '#0a1228');
      bg.addColorStop(1, '#080510');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, transitCanvas.width, transitCanvas.height);

      // Draw natal wheel at 92% size
      const wheelSize = displaySize * dpr * 0.92;
      const cx = (displaySize * dpr) / 2;
      const cy = (displaySize * dpr) / 2;
      drawChartWheel(ctx, natalChart, wheelSize, cx, cy);

      // Draw transit planets on outer rim
      const scale = wheelSize / 1100;
      const R_TRANSIT = 510;
      const natalAngles = Array.isArray(natalChart.angles) ? natalChart.angles : [];
      const natalAsc = natalAngles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');
      const ascLong = natalAsc ? Number(natalAsc.longitude || 0) : 0;
      function longToAngle(lng: number): number {
        return Math.PI - ((lng - ascLong) * Math.PI) / 180;
      }

      ctx.save();
      ctx.translate(cx, cy);
      ctx.scale(scale, scale);
      for (const tPos of transitPositions) {
        const body = displayBody(tPos?.body);
        const lng = Number(tPos?.longitude || 0);
        const sign = normalizeSign(tPos?.sign);
        const color = SIGN_COLORS[sign] || '#d6af72';
        const glyph = PLANET_GLYPHS[body] || '';
        const a = longToAngle(lng);
        const x = Math.cos(a) * R_TRANSIT;
        const y = Math.sin(a) * R_TRANSIT;

        // Hollow circle marker for transits
        ctx.strokeStyle = `${color}90`;
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x, y, 16, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = `${color}20`;
        ctx.fill();

        ctx.fillStyle = `${color}cc`;
        ctx.font = '400 22px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(glyph, x, y + 1);
      }

      // Draw transit-to-natal aspect lines
      const natalPositions = Array.isArray(natalChart.positions) ? natalChart.positions : [];
      const natalLongMap: Record<string, number> = {};
      for (const np of natalPositions) {
        natalLongMap[String(np?.body || '').toLowerCase()] = Number(np?.longitude || zodiacDegrees(np?.sign, np?.degree));
      }
      const R_INNER = 255;
      for (const asp of transitAspects) {
        const type = String(asp?.type || asp?.aspect_type || '').toLowerCase();
        const color = CHART_ASPECT_COLORS[type];
        if (!color) continue;
        // Transit body → natal body
        const transitBody = String(asp?.body1 || '').toLowerCase();
        const natalBody = String(asp?.body2 || '').toLowerCase();
        const transitLng = transitPositions.find((p: any) => String(p?.body || '').toLowerCase() === transitBody);
        const natalLng = natalLongMap[natalBody];
        if (!transitLng || natalLng == null) continue;
        const a1 = longToAngle(Number(transitLng.longitude || 0));
        const a2 = longToAngle(natalLng);
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.3;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(Math.cos(a1) * R_TRANSIT, Math.sin(a1) * R_TRANSIT);
        ctx.lineTo(Math.cos(a2) * (R_INNER - 10), Math.sin(a2) * (R_INNER - 10));
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.setLineDash([]);
      ctx.restore();

      // Transit list below wheel
      if (transitContent) {
        const transitItems = transitPositions.map((tp: any) => {
          const body = displayBody(tp?.body);
          const sign = normalizeSign(tp?.sign);
          const deg = Number(tp?.degree || 0).toFixed(1);
          const glyph = PLANET_GLYPHS[body] || '';
          const signGlyph = SIGN_GLYPHS[sign] || '';
          const color = SIGN_COLORS[sign] || '#d6af72';
          const retro = Boolean(tp?.retrograde);
          return `<div class="chart-placement" data-tip="${escapeHtml((PLANET_TIPS[body] || '') + ' (transit)')}">
            <span class="chart-placement-glyph" style="color: ${color}">${escapeHtml(glyph)}</span>
            <span class="chart-placement-name">${escapeHtml(body)}${retro ? ' <span class="chart-retro">\u211E</span>' : ''}</span>
            <span class="chart-placement-detail">${escapeHtml(deg)}\u00B0 ${escapeHtml(signGlyph)} ${escapeHtml(sign)}</span>
          </div>`;
        }).join('');
        transitContent.innerHTML = `<div class="chart-placements">${transitItems}</div>`;
      }
    } catch {
      // Transit overlay is non-critical; silently fail
    }
  }

  async function exportNatalChartImage(chart: Record<string, unknown>) {
    const data = chart as any;
    const positions = Array.isArray(data.positions) ? (data.positions as any[]) : [];
    const angles = Array.isArray(data.angles) ? (data.angles as any[]) : [];
    const aspects = Array.isArray(data.aspects) ? (data.aspects as any[]) : [];
    const houseCusps = Array.isArray(data.house_cusps) ? (data.house_cusps as number[]) : [];
    const houseSystem = String(data.house_system || 'Placidus');
    if (positions.length === 0) throw new Error('No chart data to export.');

    await ensureFontsLoaded();

    // Pre-compute canvas height from data
    const _placementRows = Math.ceil(positions.length / 2);
    const _panelEst = 60
      + (56 + _placementRows * 62 + 14)   // placements
      + 30                                  // divider
      + (42 + 48 + 18)                     // core signature (label + gap + row + pad)
      + 30                                  // divider
      + 50;                                 // footer line
    const H = 1380 + _panelEst + 160;

    const canvas = document.createElement('canvas');
    canvas.width = 1800;
    canvas.height = H;
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Could not initialize image export.');

    const W = 1800;
    const CX = 900, CY = 800;
    const BRASS = '#d6af72';

    const ascAngle = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'ascendant');

    function createSeededRng(pos: any[]): () => number {
      let s = 0;
      for (const p of pos) {
        const lng = Number(p?.longitude || zodiacDegrees(p?.sign, p?.degree));
        s = (s * 31 + Math.round(lng * 100)) | 0;
      }
      s = Math.abs(s) || 12345;
      return () => { s = (s * 1103515245 + 12345) & 0x7fffffff; return s / 0x7fffffff; };
    }

    const rng = createSeededRng(positions);

    function drawRoundedRect(x: number, y: number, w: number, h: number, radius: number) {
      const r = Math.max(0, Math.min(radius, Math.min(w, h) / 2));
      ctx!.beginPath();
      ctx!.moveTo(x + r, y);
      ctx!.lineTo(x + w - r, y);
      ctx!.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx!.lineTo(x + w, y + h - r);
      ctx!.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx!.lineTo(x + r, y + h);
      ctx!.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx!.lineTo(x, y + r);
      ctx!.quadraticCurveTo(x, y, x + r, y);
      ctx!.closePath();
    }

    // --- Layer 1: Background gradient ---
    const bg = ctx.createLinearGradient(0, 0, W, H);
    bg.addColorStop(0, '#05070f');
    bg.addColorStop(0.35, '#0a1228');
    bg.addColorStop(0.65, '#0e0a20');
    bg.addColorStop(1, '#080510');
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, W, H);

    // --- Layer 2: Nebula glows ---
    const nebulae = [
      { x: CX - 200, y: CY - 100, r: 600, color: [70, 110, 180] },
      { x: CX + 250, y: CY + 50, r: 500, color: [180, 145, 80] },
      { x: CX - 50, y: CY + 200, r: 550, color: [90, 50, 130] },
    ];
    for (const n of nebulae) {
      const g = ctx.createRadialGradient(n.x, n.y, 30, n.x, n.y, n.r);
      g.addColorStop(0, `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, 0.18)`);
      g.addColorStop(0.5, `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, 0.06)`);
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);
    }

    // --- Layer 3: Star field ---
    for (let i = 0; i < 350; i++) {
      const x = rng() * W, y = rng() * H * 0.85;
      const sz = rng() * 1.2 + 0.3, a = rng() * 0.25 + 0.05;
      ctx.fillStyle = `rgba(220, 226, 240, ${a.toFixed(3)})`;
      ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.fill();
    }
    for (let i = 0; i < 80; i++) {
      const x = rng() * W, y = rng() * H * 0.8;
      const sz = rng() * 1.8 + 0.8, a = rng() * 0.45 + 0.2;
      const warm = rng() > 0.5;
      ctx.fillStyle = warm ? `rgba(240, 220, 180, ${a.toFixed(3)})` : `rgba(200, 215, 255, ${a.toFixed(3)})`;
      ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.fill();
    }
    for (let i = 0; i < 12; i++) {
      const x = rng() * W, y = rng() * H * 0.7;
      const sz = rng() * 1.5 + 1.5;
      const halo = ctx.createRadialGradient(x, y, 0, x, y, sz * 6);
      halo.addColorStop(0, 'rgba(220, 230, 255, 0.15)');
      halo.addColorStop(1, 'rgba(220, 230, 255, 0)');
      ctx.fillStyle = halo;
      ctx.beginPath(); ctx.arc(x, y, sz * 6, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'rgba(245, 248, 255, 0.8)';
      ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = 'rgba(230, 238, 255, 0.25)';
      ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.moveTo(x - sz * 4, y); ctx.lineTo(x + sz * 4, y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, y - sz * 4); ctx.lineTo(x, y + sz * 4); ctx.stroke();
    }

    drawChartWheel(ctx, chart, 1100, CX, CY);

    // --- Layer 10: Header ---
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';

    ctx.fillStyle = BRASS;
    ctx.font = '600 22px "Inter", sans-serif';
    ctx.fillText('V O I D W I R E', CX, 80);

    ctx.fillStyle = '#efe8d9';
    ctx.font = '400 64px "EB Garamond", Georgia, serif';
    ctx.fillText('Natal Chart', CX, 160);

    ctx.fillStyle = BRASS;
    ctx.save();
    ctx.translate(CX, 200);
    ctx.rotate(Math.PI / 4);
    ctx.fillRect(-5, -5, 10, 10);
    ctx.restore();

    ctx.strokeStyle = `${BRASS}40`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(CX - 120, 200); ctx.lineTo(CX - 18, 200); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(CX + 18, 200); ctx.lineTo(CX + 120, 200); ctx.stroke();

    // --- Layer 11: Data panel (stacked full-width sections) ---
    const panelTop = 1380;
    const panelLeft = 80;
    const panelRight = W - 80;
    const panelW = panelRight - panelLeft;
    const contentLeft = panelLeft + 50;
    const contentRight = panelRight - 50;
    const contentW = contentRight - contentLeft;

    // Pre-sort data for layout calculation
    const sortedPos = [...positions].sort(
      (a, b) => zodiacDegrees(a?.sign, a?.degree) - zodiacDegrees(b?.sign, b?.degree),
    );

    // Layout constants — generous sizing for phone readability
    const placeRowH = 62;
    const coreRowH = 48;
    const placementRows = Math.ceil(sortedPos.length / 2);

    // Pre-compute panel height from data
    const panelHeight = 60
      + 56 + placementRows * placeRowH + 14   // placements
      + 30                                      // divider
      + 42 + coreRowH + 18                     // core signature (label + gap + row + pad)
      + 30                                      // divider
      + 50;                                     // footer line

    // Draw panel background
    ctx.fillStyle = 'rgba(8, 12, 24, 0.8)';
    drawRoundedRect(panelLeft, panelTop, panelW, panelHeight, 24);
    ctx.fill();
    ctx.strokeStyle = 'rgba(214, 175, 114, 0.2)';
    ctx.lineWidth = 1.5;
    drawRoundedRect(panelLeft, panelTop, panelW, panelHeight, 24);
    ctx.stroke();

    // Drawing helpers
    function drawPanelHeader(label: string, y: number): number {
      ctx.fillStyle = BRASS;
      ctx.font = '600 34px "EB Garamond", Georgia, serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
      let xPos = contentLeft;
      for (const ch of label) {
        ctx.fillText(ch, xPos, y);
        xPos += ctx.measureText(ch).width + 2.5;
      }
      ctx.strokeStyle = `${BRASS}20`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(contentLeft, y + 12);
      ctx.lineTo(contentRight, y + 12);
      ctx.stroke();
      return y + 50;
    }

    function drawPanelDivider(y: number): number {
      ctx.strokeStyle = 'rgba(214, 175, 114, 0.10)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(contentLeft + 40, y);
      ctx.lineTo(contentRight - 40, y);
      ctx.stroke();
      return y + 30;
    }

    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    let panelY = panelTop + 60;

    // ── PLACEMENTS (2 columns, inset to align with core signature) ──
    // Centered header with letter-spacing
    ctx.fillStyle = BRASS;
    ctx.font = '600 34px "EB Garamond", Georgia, serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';
    const _plLabel = 'PLACEMENTS';
    const _plSpacing = 2.5;
    let _plTotalW = 0;
    for (const ch of _plLabel) _plTotalW += ctx.measureText(ch).width + _plSpacing;
    _plTotalW -= _plSpacing;
    let _plX = CX - _plTotalW / 2;
    for (const ch of _plLabel) { ctx.fillText(ch, _plX, panelY); _plX += ctx.measureText(ch).width + _plSpacing; }
    ctx.strokeStyle = `${BRASS}20`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(contentLeft, panelY + 12); ctx.lineTo(contentRight, panelY + 12); ctx.stroke();
    panelY += 56;
    const placeInset = 160;
    const placeLeft = contentLeft + placeInset;
    const placeColW = (contentW - 2 * placeInset) / 2;

    for (let i = 0; i < sortedPos.length; i++) {
      const pos = sortedPos[i];
      const colX = placeLeft + (i % 2) * placeColW;
      const row = Math.floor(i / 2);
      const y = panelY + row * placeRowH;

      const rawBody = String(pos?.body || '');
      const body = displayBody(rawBody);
      const glyph = PLANET_GLYPHS[body] || PLANET_GLYPHS[rawBody] || '';
      const sign = normalizeSign(pos?.sign);
      const deg = Number(pos?.degree || 0).toFixed(1);
      const house = pos?.house ? `H${pos.house}` : '';
      const retro = Boolean(pos?.retrograde);
      const signGlyph = SIGN_GLYPHS[sign] || '';
      const color = SIGN_COLORS[sign] || '#d6af72';

      // Planet glyph
      ctx.fillStyle = color;
      ctx.font = '400 36px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
      ctx.fillText(glyph, colX, y);

      // Planet name
      ctx.fillStyle = '#e0d8c8';
      ctx.font = '600 30px "EB Garamond", Georgia, serif';
      const bodyW = ctx.measureText(body).width;
      ctx.fillText(body, colX + 44, y);

      // Retrograde indicator — muted glyph, blended with palette
      if (retro) {
        ctx.fillStyle = '#8898b8';
        ctx.font = '400 20px "EB Garamond", Georgia, serif';
        ctx.fillText('\u211E', colX + 44 + bodyW + 5, y - 8);
      }

      // Degree · sign · house (inline after name)
      ctx.fillStyle = '#6f7a8e';
      ctx.font = '400 28px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
      const detailX = colX + 44 + bodyW + (retro ? 24 : 12);
      ctx.fillText(`${deg}\u00B0 ${signGlyph} ${sign}${house ? ' \u00B7 ' + house : ''}`, detailX, y);
    }
    panelY += placementRows * placeRowH + 14;

    // ── CORE SIGNATURE (single row, three equal center-aligned columns) ──
    panelY = drawPanelDivider(panelY);
    ctx.fillStyle = `${BRASS}80`;
    ctx.font = '600 22px "EB Garamond", Georgia, serif';
    ctx.textAlign = 'center';
    ctx.fillText('CORE SIGNATURE', CX, panelY + 6);
    ctx.textAlign = 'left';
    panelY += 42;

    const sun = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'sun');
    const moon = positions.find((p: any) => String(p?.body || '').toLowerCase() === 'moon');
    const coreItems = [
      sun ? `${PLANET_GLYPHS['Sun'] || ''} Sun  ${normalizeSign(sun.sign)} ${Number(sun.degree || 0).toFixed(1)}\u00B0` : null,
      moon ? `${PLANET_GLYPHS['Moon'] || ''} Moon  ${normalizeSign(moon.sign)} ${Number(moon.degree || 0).toFixed(1)}\u00B0` : null,
      ascAngle ? `ASC  ${normalizeSign(ascAngle.sign)} ${Number(ascAngle.degree || 0).toFixed(1)}\u00B0` : null,
    ].filter(Boolean) as string[];

    const coreColW = contentW / coreItems.length;
    for (let i = 0; i < coreItems.length; i++) {
      const cx = contentLeft + coreColW * i + coreColW / 2;
      ctx.fillStyle = '#d0c8b8';
      ctx.font = '400 28px "Segoe UI Symbol", "EB Garamond", Georgia, serif';
      ctx.textAlign = 'center';
      ctx.fillText(coreItems[i], cx, panelY);
    }
    ctx.textAlign = 'left';
    panelY += coreRowH + 18;

    // ── Footer: Ascendant · Midheaven · House System ──
    panelY = drawPanelDivider(panelY);
    const mcAngle = angles.find((a: any) => String(a?.name || '').toLowerCase() === 'midheaven' || String(a?.name || '').toLowerCase() === 'mc');
    const footerParts: string[] = [];
    if (ascAngle) footerParts.push(`Asc ${Number(ascAngle.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(ascAngle.sign)}`);
    if (mcAngle) footerParts.push(`MC ${Number(mcAngle.degree || 0).toFixed(1)}\u00B0 ${normalizeSign(mcAngle.sign)}`);
    footerParts.push(houseSystem);
    ctx.fillStyle = '#6f7a8e';
    ctx.font = '400 26px "EB Garamond", Georgia, serif';
    ctx.textAlign = 'center';
    ctx.fillText(footerParts.join('  \u00B7  '), CX, panelY + 14);
    ctx.textAlign = 'left';

    const panelBottom = panelTop + panelHeight;

    // --- Layer 12: Vignette + grain ---
    const vig = ctx.createRadialGradient(CX, H / 2, H * 0.25, CX, H / 2, H * 0.75);
    vig.addColorStop(0, 'rgba(0, 0, 0, 0)');
    vig.addColorStop(0.7, 'rgba(0, 0, 0, 0)');
    vig.addColorStop(1, 'rgba(0, 0, 0, 0.45)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);

    const grainCanvas = document.createElement('canvas');
    grainCanvas.width = 200;
    grainCanvas.height = 200;
    const gctx = grainCanvas.getContext('2d');
    if (gctx) {
      const gData = gctx.createImageData(200, 200);
      for (let i = 0; i < gData.data.length; i += 4) {
        const v = (rng() * 255) | 0;
        gData.data[i] = v; gData.data[i + 1] = v; gData.data[i + 2] = v; gData.data[i + 3] = 255;
      }
      gctx.putImageData(gData, 0, 0);
      ctx.globalAlpha = 0.03;
      ctx.globalCompositeOperation = 'overlay';
      const pattern = ctx.createPattern(grainCanvas, 'repeat');
      if (pattern) { ctx.fillStyle = pattern; ctx.fillRect(0, 0, W, H); }
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }

    // --- Layer 13: Footer (positioned relative to panel bottom) ---
    const footerLineY = panelBottom + 50;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'alphabetic';

    ctx.strokeStyle = `${BRASS}40`;
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(W * 0.2, footerLineY); ctx.lineTo(W * 0.8, footerLineY); ctx.stroke();

    ctx.fillStyle = `${BRASS}90`;
    ctx.font = '400 22px "JetBrains Mono", monospace';
    ctx.fillText(chartBrandDomain, CX, footerLineY + 40);

    for (let i = -1; i <= 1; i++) {
      ctx.fillStyle = `${BRASS}50`;
      ctx.beginPath(); ctx.arc(CX + i * 16, footerLineY + 76, 2.5, 0, Math.PI * 2); ctx.fill();
    }

    const blob = await new Promise<Blob | null>((resolve) => canvas.toBlob(resolve, 'image/jpeg', 0.92));
    if (!blob) throw new Error('Could not generate chart image.');
    return blob;
  }

  async function exportAccountData() {
    try {
      const res = await authFetch('/v1/user/auth/me/export');
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data?.detail || 'Could not export account');
      }
      const payload = await res.json();
      const stamp = new Date().toISOString().slice(0, 10);
      downloadJson(`voidwire-account-${stamp}.json`, payload);
    } catch (err) {
      alert(err instanceof Error ? err.message : 'Could not export account data');
    }
  }

  async function loadDashboard() {
    try {
      const meRes = await authFetch('/v1/user/auth/me');
      if (!meRes.ok) {
        if (meRes.status === 401) {
          clearToken();
          window.location.href = '/login';
          return;
        }
        throw new Error('Failed to load user info');
      }

      const me = (await meRes.json()) as DashboardUser;
      void loadBrandDomain();
      hasProfile = !!me.has_profile;
      canManageReadings = Boolean(me.is_admin_user || me.is_test_user);
      setReadingActionVisibility();
      const userInfo = document.getElementById('user-info');
      if (userInfo) {
        const tier = me.tier === 'pro' ? 'pro' : 'free';
        const displayName = me.display_name ? escapeHtml(me.display_name) : '';
        const roleTag = me.is_admin_user ? 'Admin' : me.is_test_user ? 'Test' : '';
        userInfo.innerHTML = `
          <div class="info-row"><span class="info-label">Email</span><span class="info-value">${escapeHtml(me.email)}</span></div>
          ${displayName ? `<div class="info-row"><span class="info-label">Name</span><span class="info-value">${displayName}</span></div>` : ''}
          <div class="info-row"><span class="info-label">Tier</span><span class="info-value tier-${tier}">${tier.toUpperCase()}</span></div>
          ${roleTag ? `<div class="info-row"><span class="info-label">Privileges</span><span class="info-value">${escapeHtml(roleTag)}</span></div>` : ''}
          <div class="info-row"><span class="info-label">Email Status</span><span class="info-value">${me.email_verified ? 'Verified' : 'Unverified'}</span></div>
        `;
      }

      const onboarding = document.getElementById('onboarding-message');
      const readingSection = document.getElementById('reading-section');
      const profileStatus = document.getElementById('profile-status');
      const birthFormWrapper = document.getElementById('birth-form-wrapper');
      const toggleBirthFormButton = document.getElementById('toggle-birth-form');
      const viewReadingButton = document.getElementById('view-reading-btn') as HTMLButtonElement | null;

      if (!hasProfile) {
        if (onboarding) {
          onboarding.style.display = 'block';
          onboarding.innerHTML = 'Set your birth data in Settings to unlock personalized readings.';
        }
        if (readingSection) readingSection.style.display = 'none';
        const chartStatus = document.getElementById('chart-status');
        if (chartStatus) {
          chartStatus.className = 'reading-status';
          chartStatus.textContent = 'Add birth data to generate your natal chart.';
        }
        if (profileStatus) {
          profileStatus.innerHTML = '<p class="profile-prompt">Add your birth data to generate natal-chart-based readings.</p>';
        }
        if (birthFormWrapper) birthFormWrapper.style.display = 'block';
        if (toggleBirthFormButton) toggleBirthFormButton.style.display = 'none';
        if (viewReadingButton) viewReadingButton.disabled = true;
        // Open Birth Data section when no profile exists
        const birthDataBody = document.getElementById('birth-data-body');
        const birthDataToggle = document.querySelector('[data-target="birth-data-body"]');
        if (birthDataBody) birthDataBody.classList.remove('collapsed');
        if (birthDataToggle) birthDataToggle.classList.add('open');
        setView('settings');
        return;
      }

      if (onboarding) onboarding.style.display = 'none';
      if (readingSection) readingSection.style.display = 'block';
      if (viewReadingButton) viewReadingButton.disabled = false;

      const profileRes = await authFetch('/v1/user/profile/');
      if (profileRes.ok) {
        const profile = await profileRes.json();
        if (profileStatus) {
          profileStatus.innerHTML = `
            <div class="profile-summary">
              <div class="info-row"><span class="info-label">Birth Date</span><span class="info-value">${escapeHtml(profile.birth_date || '')}</span></div>
              <div class="info-row"><span class="info-label">Location</span><span class="info-value">${escapeHtml(profile.birth_city || '')}</span></div>
              <div class="info-row"><span class="info-label">Timezone</span><span class="info-value">${escapeHtml(profile.birth_timezone || '')}</span></div>
              <div class="info-row"><span class="info-label">House System</span><span class="info-value">${escapeHtml(profile.house_system || '')}</span></div>
            </div>
          `;
        }
      }
      if (toggleBirthFormButton) toggleBirthFormButton.style.display = 'inline-flex';
      if (birthFormWrapper) birthFormWrapper.style.display = 'none';

      void loadNatalChart();
      setView('reading');
      await startReadingFlow();
    } catch (err) {
      console.error('Dashboard load error:', err);
      renderReadingMessage('Could not load dashboard.');
      updateReadingStatus('Could not load dashboard.');
    }
  }

  document.getElementById('view-reading-btn')?.addEventListener('click', () => {
    if (!hasProfile) return;
    setView('reading');
  });

  document.getElementById('view-settings-btn')?.addEventListener('click', () => {
    setView('settings');
  });


  document.getElementById('toggle-birth-form')?.addEventListener('click', () => {
    const birthFormWrapper = document.getElementById('birth-form-wrapper');
    if (!birthFormWrapper) return;
    birthFormWrapper.style.display = birthFormWrapper.style.display === 'none' ? 'block' : 'none';
  });

  document.getElementById('export-chart-text-btn')?.addEventListener('click', async () => {
    if (!cachedChart) return;
    const btn = document.getElementById('export-chart-text-btn') as HTMLButtonElement | null;
    try {
      await navigator.clipboard.writeText(natalChartText(cachedChart));
      if (btn) {
        const original = btn.textContent;
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = original; }, 2000);
      }
    } catch {
      const stamp = new Date().toISOString().slice(0, 10);
      downloadText(`voidwire-natal-chart-${stamp}.txt`, natalChartText(cachedChart));
    }
  });

  document.getElementById('export-chart-image-btn')?.addEventListener('click', async () => {
    if (!cachedChart) return;
    const btn = document.getElementById('export-chart-image-btn') as HTMLButtonElement | null;
    const original = btn?.textContent || 'Share Chart Image';
    try {
      if (btn) btn.textContent = 'Preparing\u2026';
      const blob = await exportNatalChartImage(cachedChart);
      const stamp = new Date().toISOString().slice(0, 10);
      const filename = `voidwire-natal-chart-${stamp}.jpg`;
      const file = new File([blob], filename, { type: 'image/jpeg' });
      if (typeof navigator.share === 'function' && navigator.canShare?.({ files: [file] })) {
        await navigator.share({ title: 'My Natal Chart', files: [file] });
      } else {
        downloadBlob(filename, blob);
      }
    } catch (err) {
      if ((err as any)?.name !== 'AbortError') {
        alert(err instanceof Error ? err.message : 'Could not export chart image');
      }
    } finally {
      if (btn) btn.textContent = original;
    }
  });

  document.getElementById('export-account-btn')?.addEventListener('click', () => {
    void exportAccountData();
  });

  // --- Collapsible section toggles ---
  for (const toggle of document.querySelectorAll('.section-toggle')) {
    toggle.addEventListener('click', () => {
      const targetId = toggle.getAttribute('data-target');
      if (!targetId) return;
      const body = document.getElementById(targetId);
      if (!body) return;
      body.classList.toggle('collapsed');
      toggle.classList.toggle('open', !body.classList.contains('collapsed'));
    });
  }

  // --- Delete account modal ---
  const deleteLink = document.getElementById('delete-account-link');
  const deleteModal = document.getElementById('delete-account-modal');
  const deleteConfirmInput = document.getElementById('delete-confirm-input') as HTMLInputElement | null;
  const deleteConfirmBtn = document.getElementById('delete-confirm-btn') as HTMLButtonElement | null;
  const deleteCancelBtn = document.getElementById('delete-cancel-btn');
  const deleteError = document.getElementById('delete-error');
  const deletePasswordRow = document.getElementById('delete-password-row');
  const deletePasswordInput = document.getElementById('delete-password-input') as HTMLInputElement | null;

  function showDeleteModal() {
    if (deleteModal) deleteModal.style.display = 'flex';
    if (deleteConfirmInput) { deleteConfirmInput.value = ''; deleteConfirmInput.focus(); }
    if (deleteConfirmBtn) deleteConfirmBtn.disabled = true;
    if (deleteError) deleteError.textContent = '';
    if (deletePasswordRow) deletePasswordRow.style.display = 'none';
    if (deletePasswordInput) deletePasswordInput.value = '';
  }

  function hideDeleteModal() {
    if (deleteModal) deleteModal.style.display = 'none';
    if (deleteConfirmInput) deleteConfirmInput.value = '';
    if (deleteConfirmBtn) deleteConfirmBtn.disabled = true;
    if (deleteError) deleteError.textContent = '';
    if (deletePasswordRow) deletePasswordRow.style.display = 'none';
    if (deletePasswordInput) deletePasswordInput.value = '';
  }

  deleteLink?.addEventListener('click', () => showDeleteModal());
  deleteCancelBtn?.addEventListener('click', () => hideDeleteModal());
  deleteModal?.addEventListener('click', (e) => {
    if (e.target === deleteModal) hideDeleteModal();
  });

  deleteConfirmInput?.addEventListener('input', () => {
    if (deleteConfirmBtn) {
      deleteConfirmBtn.disabled = deleteConfirmInput.value !== 'DELETE';
    }
  });

  deleteConfirmBtn?.addEventListener('click', async () => {
    if (!deleteConfirmInput || deleteConfirmInput.value !== 'DELETE') return;
    if (deleteConfirmBtn) deleteConfirmBtn.disabled = true;
    if (deleteError) deleteError.textContent = '';
    try {
      const body: Record<string, string> = {};
      if (deletePasswordInput && deletePasswordInput.value) {
        body.password = deletePasswordInput.value;
      }
      const res = await authFetch('/v1/user/auth/me', {
        method: 'DELETE',
        body: Object.keys(body).length > 0 ? JSON.stringify(body) : undefined,
      });
      if (res.status === 400) {
        const data = await res.json().catch(() => ({}));
        if (String(data?.detail || '').toLowerCase().includes('password')) {
          if (deletePasswordRow) deletePasswordRow.style.display = 'block';
          if (deletePasswordInput) deletePasswordInput.focus();
          if (deleteError) deleteError.textContent = 'Password required to delete account.';
          if (deleteConfirmBtn) deleteConfirmBtn.disabled = false;
          return;
        }
        throw new Error(data?.detail || 'Could not delete account');
      }
      if (!res.ok) {
        const data = await res.json().catch(() => ({}));
        throw new Error(data?.detail || 'Could not delete account');
      }
      clearToken();
      window.location.href = '/';
    } catch (err) {
      if (deleteError) deleteError.textContent = err instanceof Error ? err.message : 'Could not delete account';
      if (deleteConfirmBtn) deleteConfirmBtn.disabled = false;
    }
  });

  document.getElementById('logout-button')?.addEventListener('click', async () => {
    try {
      await authFetch('/v1/user/auth/logout', { method: 'POST' });
    } catch {
      // Always clear local legacy tokens regardless of network state.
    }
    clearToken();
    window.location.href = '/login';
  });

  window.addEventListener('beforeunload', () => {
    stopReadingPolling();
  });

  // --- Interactive chart wheel (click/tap planet to see details) ---
  (() => {
    const wheelCanvas = document.getElementById('chart-wheel-canvas');
    if (!wheelCanvas) return;
    wheelCanvas.style.cursor = 'pointer';
    wheelCanvas.addEventListener('click', (e) => {
      if (!cachedChart || chartPlanetScreenPositions.length === 0) return;
      const rect = wheelCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const scaleX = rect.width > 0 ? 1 : 1;
      let nearest: typeof chartPlanetScreenPositions[0] | null = null;
      let nearestDist = Infinity;
      for (const p of chartPlanetScreenPositions) {
        const dx = mx - p.sx, dy = my - p.sy;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < nearestDist) { nearestDist = dist; nearest = p; }
      }
      if (!nearest || nearestDist > 30) return;
      // Build detail text for tooltip
      const aspects = Array.isArray((cachedChart as any)?.aspects) ? (cachedChart as any).aspects : [];
      const bodyAspects = aspects.filter((a: any) =>
        displayBody(a?.body1) === nearest!.body || displayBody(a?.body2) === nearest!.body
      ).filter((a: any) => String(a?.significance || '').toLowerCase() !== 'minor');
      const aspectLines = bodyAspects.map((a: any) => {
        const other = displayBody(a.body1) === nearest!.body ? displayBody(a.body2) : displayBody(a.body1);
        const type = String(a?.type || a?.aspect_type || '');
        const orb = Number(a?.orb_degrees || a?.orb || 0).toFixed(1);
        return `${type} ${other} (${orb}\u00B0)`;
      }).join(', ');
      const dignity = getDignity(nearest.body, nearest.sign);
      const dignityLabel = dignity ? ` \u2014 ${DIGNITY_LABELS[dignity]?.label || ''}` : '';
      const planetTip = PLANET_TIPS[nearest.body] || '';
      let tipText = `${nearest.body}: ${nearest.deg}\u00B0 ${nearest.sign}`;
      if (nearest.house) tipText += ` \u00B7 ${nearest.house}`;
      if (nearest.retro) tipText += ' (Retrograde)';
      if (dignityLabel) tipText += dignityLabel;
      if (planetTip) tipText += ` \u2014 ${planetTip}`;
      if (aspectLines) tipText += `\nAspects: ${aspectLines}`;
      // Show via custom tooltip
      const tipEl = document.querySelector('.tip-popup') as HTMLElement;
      if (tipEl) {
        tipEl.textContent = tipText;
        tipEl.style.display = 'block';
        tipEl.style.left = `${Math.min(e.clientX + 12, window.innerWidth - 300)}px`;
        tipEl.style.top = `${Math.max(e.clientY - 60, 8)}px`;
        setTimeout(() => { tipEl.style.display = 'none'; }, 5000);
      }
    });
  })();

  // --- Custom tooltip system (works on hover + tap) ---
  (() => {
    const tip = document.createElement('div');
    tip.className = 'tip-popup';
    tip.style.display = 'none';
    document.body.appendChild(tip);

    let activeTarget: Element | null = null;
    let hideTimer: number | null = null;

    function showTip(target: Element) {
      const text = target.getAttribute('data-tip');
      if (!text) return;
      if (hideTimer) { clearTimeout(hideTimer); hideTimer = null; }
      activeTarget = target;
      tip.textContent = text;
      tip.style.display = 'block';

      const rect = target.getBoundingClientRect();
      const tipRect = tip.getBoundingClientRect();
      let left = rect.left + rect.width / 2 - tipRect.width / 2;
      let top = rect.top - tipRect.height - 8;

      // Flip below if no room above
      if (top < 4) top = rect.bottom + 8;
      // Clamp horizontal
      left = Math.max(8, Math.min(left, window.innerWidth - tipRect.width - 8));

      tip.style.left = `${left}px`;
      tip.style.top = `${top}px`;
    }

    function hideTip() {
      tip.style.display = 'none';
      activeTarget = null;
    }

    function scheduledHide() {
      hideTimer = window.setTimeout(hideTip, 120);
    }

    // Desktop: hover
    document.addEventListener('mouseenter', (e) => {
      const target = (e.target as Element)?.closest?.('[data-tip]');
      if (target && target.getAttribute('data-tip')) showTip(target);
    }, true);
    document.addEventListener('mouseleave', (e) => {
      const target = (e.target as Element)?.closest?.('[data-tip]');
      if (target && target === activeTarget) scheduledHide();
    }, true);

    // Mobile: tap to show, tap elsewhere to dismiss
    document.addEventListener('click', (e) => {
      const target = (e.target as Element)?.closest?.('[data-tip]');
      if (target && target.getAttribute('data-tip')) {
        if (activeTarget === target) {
          hideTip();
        } else {
          showTip(target);
        }
      } else {
        if (activeTarget) hideTip();
      }
    });
  })();

  void loadDashboard();
</script>

<style>
  :global(.tip-popup) {
    position: fixed;
    z-index: 2000;
    max-width: 280px;
    padding: 0.5rem 0.75rem;
    background: #181c2a;
    border: 1px solid rgba(214, 175, 114, 0.2);
    border-radius: 6px;
    font-family: var(--font-sans);
    font-size: 0.68rem;
    line-height: 1.45;
    color: var(--text-secondary);
    pointer-events: none;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
  }

  .dashboard-container {
    max-width: var(--max-width);
    margin: 1rem auto;
    padding: 0 1.5rem;
  }

  .dashboard-header {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    align-items: center;
  }

  .page-title {
    font-family: var(--font-sans);
    font-size: 0.75rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--accent);
    text-align: center;
    margin-bottom: 0.25rem;
    font-weight: 500;
  }

  .view-toggle {
    display: inline-flex;
    border: 1px solid var(--text-ghost);
  }

  .view-toggle-button {
    background: transparent;
    border: none;
    color: var(--text-muted);
    padding: 0.55rem 1rem;
    font-family: var(--font-sans);
    font-size: 0.62rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    cursor: pointer;
  }

  .view-toggle-button.active {
    color: var(--accent);
    background: var(--accent-glow);
  }

  .view-toggle-button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .onboarding-message {
    font-family: var(--font-sans);
    font-size: 0.8rem;
    color: var(--text-muted);
    text-align: center;
    margin: 1rem 0 0.5rem;
  }

  .section-label {
    font-family: var(--font-sans);
    font-size: 0.6rem;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
    margin-top: 1.2rem;
    padding-bottom: 0.4rem;
    border-bottom: 1px solid var(--text-ghost);
  }

  .reading-status {
    font-family: var(--font-sans);
    font-size: 0.72rem;
    color: var(--text-muted);
    text-align: center;
    margin-bottom: 0.5rem;
  }

  .reading-content :global(.loading),
  .reading-content :global(.muted) {
    font-family: var(--font-sans);
    font-size: 0.8rem;
    color: var(--text-muted);
    text-align: center;
    padding: 2rem;
  }

  .reading-content :global(.reading-tier-badge) {
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    color: var(--accent);
    text-align: center;
    margin-bottom: 0.75rem;
  }

  .reading-content :global(.reading-title) {
    font-family: var(--font-body);
    font-size: 1.6rem;
    color: var(--text-primary);
    text-align: center;
    font-weight: 400;
    margin-bottom: 0.5rem;
  }

  .reading-content :global(.reading-meta) {
    font-family: var(--font-mono);
    font-size: 0.58rem;
    color: var(--text-muted);
    text-align: center;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    margin-bottom: 1rem;
  }

  .reading-content :global(.reading-body) {
    font-size: 1.05rem;
    color: var(--text-primary);
    line-height: var(--line-height);
  }

  .reading-content :global(.reading-body p) {
    margin-bottom: 1.5em;
  }

  .reading-content :global(.section-heading) {
    font-family: var(--font-sans);
    font-size: 0.65rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--accent);
    margin-top: 1.2rem;
    margin-bottom: 0.5rem;
    font-weight: 500;
  }

  .reading-content :global(.reading-template) {
    margin-top: 1rem;
    font-family: var(--font-mono);
    font-size: 0.6rem;
    color: var(--text-muted);
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }

  .reading-actions {
    display: none;
    flex-wrap: wrap;
    gap: 0.6rem;
    margin-top: 0.6rem;
  }

  .reading-actions.visible {
    display: flex;
  }

  .chart-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 0.6rem;
    margin-top: 0.6rem;
  }

  :global(.action-button),
  :global(.edit-button) {
    background: transparent;
    border: 1px solid var(--text-ghost);
    color: var(--text-secondary);
    padding: 0.55rem 0.9rem;
    font-family: var(--font-sans);
    font-size: 0.62rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  :global(.action-button:hover),
  :global(.edit-button:hover) {
    border-color: var(--accent);
    color: var(--accent);
  }

  .user-info,
  .profile-summary {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  :global(.info-row) {
    display: flex;
    justify-content: space-between;
    font-family: var(--font-sans);
    font-size: 0.8rem;
    padding: 0.3rem 0;
  }

  :global(.info-label) {
    color: var(--text-muted);
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  :global(.info-value) {
    color: var(--text-secondary);
  }

  :global(.tier-pro) {
    color: var(--accent);
    font-weight: 500;
  }

  :global(.profile-prompt) {
    font-family: var(--font-sans);
    font-size: 0.8rem;
    color: var(--text-muted);
    margin-bottom: 1rem;
  }

  .chart-wheel-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0.8rem 0 1.2rem;
  }

  .chart-actions-centered {
    justify-content: center;
    margin-top: 0.5rem;
  }

  .chart-wheel-wrap canvas {
    border-radius: 12px;
    max-width: 100%;
    height: auto !important;
  }

  .chart-content {
    margin-top: 0.8rem;
  }

  .chart-content :global(.chart-hero) {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    padding: 1rem 0;
    margin-bottom: 1rem;
    border-top: 1px solid var(--text-ghost);
    border-bottom: 1px solid var(--text-ghost);
  }

  .chart-content :global(.chart-hero-item) {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.2rem;
  }

  .chart-content :global(.chart-hero-glyph) {
    font-family: "Segoe UI Symbol", "EB Garamond", Georgia, serif;
    font-size: 1.4rem;
    line-height: 1;
  }

  .chart-content :global(.chart-hero-label) {
    font-family: var(--font-sans);
    font-size: 0.55rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--text-muted);
  }

  .chart-content :global(.chart-hero-detail) {
    font-family: "Segoe UI Symbol", var(--font-body);
    font-size: 0.8rem;
    color: var(--text-secondary);
  }

  .chart-content :global(.chart-placements) {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.15rem 1.5rem;
    margin-bottom: 1rem;
  }

  .chart-content :global(.chart-placement) {
    display: flex;
    align-items: baseline;
    gap: 0.4rem;
    padding: 0.35rem 0;
    font-family: var(--font-sans);
    font-size: 0.78rem;
  }

  .chart-content :global(.chart-placement-glyph) {
    font-family: "Segoe UI Symbol", "EB Garamond", Georgia, serif;
    font-size: 1rem;
    flex-shrink: 0;
    width: 1.2rem;
    text-align: center;
  }

  .chart-content :global(.chart-placement-name) {
    color: var(--text-primary);
    font-weight: 500;
    white-space: nowrap;
  }

  .chart-content :global(.chart-retro) {
    color: var(--text-muted);
    font-size: 0.7rem;
    margin-left: 0.15rem;
  }

  .chart-content :global(.chart-placement-detail) {
    font-family: "Segoe UI Symbol", var(--font-body);
    color: var(--text-muted);
    font-size: 0.72rem;
    white-space: nowrap;
  }

  .chart-content :global(.chart-detail-footer) {
    text-align: center;
    font-family: var(--font-mono);
    font-size: 0.6rem;
    letter-spacing: 0.08em;
    color: var(--text-muted);
    padding-top: 0.6rem;
    border-top: 1px solid var(--text-ghost);
  }

  .logout-wrapper {
    text-align: center;
    margin: 2rem 0 3rem;
  }

  .logout-button {
    background: transparent;
    border: 1px solid var(--text-ghost);
    color: var(--text-muted);
    padding: 0.6rem 2rem;
    font-family: var(--font-sans);
    font-size: 0.65rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .logout-button:hover {
    border-color: #c45;
    color: #c45;
  }

  /* --- Collapsible sections --- */
  .section-toggle {
    cursor: pointer;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .section-toggle::after {
    content: '\25B8';
    font-size: 0.65rem;
    color: var(--text-muted);
    transition: transform 0.2s ease;
  }

  .section-toggle.open::after {
    transform: rotate(90deg);
  }

  .section-body {
    max-height: 2000px;
    overflow: hidden;
    transition: max-height 0.4s ease, opacity 0.3s ease;
    opacity: 1;
  }

  .section-body.collapsed {
    max-height: 0;
    opacity: 0;
    pointer-events: none;
  }

  /* --- Aspects grid --- */
  .chart-content :global(.chart-aspects-label) {
    font-family: var(--font-sans);
    font-size: 0.65rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--text-muted);
    text-align: center;
    margin: 1rem 0 0.5rem;
  }

  .chart-content :global(.chart-aspects) {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.15rem 1.5rem;
    margin-bottom: 1rem;
  }

  .chart-content :global(.chart-aspect) {
    display: flex;
    align-items: baseline;
    gap: 0.4rem;
    padding: 0.3rem 0;
    font-family: var(--font-sans);
    font-size: 0.75rem;
  }

  .chart-content :global(.chart-aspect-glyph) {
    font-family: "Segoe UI Symbol", "EB Garamond", Georgia, serif;
    font-size: 0.9rem;
    flex-shrink: 0;
    width: 1rem;
    text-align: center;
  }

  .chart-content :global(.chart-aspect-bodies) {
    color: var(--text-primary);
    font-weight: 500;
    white-space: nowrap;
    font-size: 0.72rem;
  }

  .chart-content :global(.chart-aspect-detail) {
    color: var(--text-muted);
    font-size: 0.65rem;
    white-space: nowrap;
  }

  /* --- Chart Details --- */
  .chart-content :global(.chart-details-label) {
    font-family: var(--font-sans);
    font-size: 0.65rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--text-muted);
    text-align: center;
    margin: 1rem 0 0.5rem;
    padding-top: 0.6rem;
    border-top: 1px solid var(--text-ghost);
  }

  .chart-content :global(.chart-details) {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-bottom: 1rem;
    padding: 0.4rem 0;
  }

  .chart-content :global(.chart-details-grid) {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0 2rem;
  }

  .chart-content :global(.chart-detail-group) {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .chart-content :global(.chart-detail-sublabel) {
    font-family: var(--font-sans);
    font-size: 0.5rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: var(--accent);
    margin-bottom: 0.2rem;
    display: block;
  }

  .chart-content :global(.chart-bar-row) {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-family: var(--font-sans);
    font-size: 0.72rem;
    cursor: default;
  }

  .chart-content :global(.chart-bar-label) {
    width: 3.8rem;
    color: var(--text-secondary);
    font-size: 0.65rem;
    text-align: right;
    flex-shrink: 0;
  }

  .chart-content :global(.chart-bar-track) {
    flex: 1;
    height: 5px;
    background: rgba(255, 255, 255, 0.04);
    border-radius: 3px;
    overflow: hidden;
  }

  .chart-content :global(.chart-bar-fill) {
    display: block;
    height: 100%;
    border-radius: 3px;
    transition: width 0.5s ease;
    opacity: 0.75;
  }

  .chart-content :global(.chart-bar-count) {
    width: 1rem;
    text-align: right;
    color: var(--text-muted);
    font-size: 0.6rem;
    font-family: var(--font-mono);
    flex-shrink: 0;
  }

  .chart-content :global(.chart-polarity) {
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: center;
    gap: 0.5rem;
    font-family: var(--font-sans);
    font-size: 0.68rem;
    cursor: default;
  }

  .chart-content :global(.chart-polarity-label) {
    font-family: var(--font-sans);
    font-size: 0.5rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: var(--accent);
  }

  .chart-content :global(.chart-polarity-bar) {
    height: 5px;
    display: flex;
    border-radius: 3px;
    overflow: hidden;
    background: rgba(255, 255, 255, 0.04);
  }

  .chart-content :global(.chart-polarity-yang) {
    background: rgba(255, 180, 100, 0.6);
  }

  .chart-content :global(.chart-polarity-yin) {
    background: rgba(130, 170, 220, 0.6);
  }

  .chart-content :global(.chart-polarity-value) {
    color: var(--text-muted);
    font-size: 0.6rem;
    white-space: nowrap;
  }

  .chart-content :global(.chart-details-highlights) {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.6rem;
    padding-top: 0.5rem;
    border-top: 1px solid var(--text-ghost);
  }

  .chart-content :global(.chart-highlight-card) {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.15rem;
    padding: 0.6rem 0.4rem;
    background: rgba(255, 255, 255, 0.015);
    border: 1px solid rgba(255, 255, 255, 0.04);
    border-radius: 6px;
    text-align: center;
    cursor: default;
  }

  .chart-content :global(.chart-highlight-value) {
    font-family: "Segoe UI Symbol", var(--font-sans);
    font-size: 0.82rem;
    color: var(--text-primary);
    font-weight: 500;
  }

  .chart-content :global(.chart-highlight-detail) {
    font-family: "Segoe UI Symbol", var(--font-sans);
    font-size: 0.58rem;
    color: var(--text-muted);
    white-space: nowrap;
  }

  .chart-content :global(.chart-details-secondary) {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding-top: 0.4rem;
    border-top: 1px solid var(--text-ghost);
  }

  .chart-content :global(.chart-stelliums) {
    display: flex;
    align-items: baseline;
    gap: 0.5rem;
    flex-wrap: wrap;
    cursor: default;
  }

  .chart-content :global(.chart-stellium-tag) {
    font-family: var(--font-sans);
    font-size: 0.68rem;
    font-weight: 500;
  }

  .chart-content :global(.chart-aspect-summary) {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .chart-content :global(.chart-aspect-stats) {
    display: flex;
    flex-wrap: wrap;
    gap: 0.3rem 0.9rem;
  }

  .chart-content :global(.chart-aspect-stat) {
    font-family: "Segoe UI Symbol", var(--font-sans);
    font-size: 0.65rem;
    white-space: nowrap;
    cursor: default;
  }

  .chart-content :global(.chart-retro-summary) {
    display: flex;
    flex-direction: column;
    gap: 0.1rem;
    cursor: default;
  }

  .chart-content :global(.chart-retro-value) {
    font-family: var(--font-sans);
    font-size: 0.68rem;
    color: var(--text-muted);
  }

  /* --- Delete account link --- */
  .delete-account-link {
    background: transparent;
    border: none;
    color: #a05050;
    font-family: var(--font-sans);
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    cursor: pointer;
    padding: 0.6rem 0;
    margin-top: 0.4rem;
    transition: color 0.2s ease;
  }

  .delete-account-link:hover {
    color: #cc4444;
  }

  /* --- Modal overlay --- */
  :global(.modal-overlay) {
    position: fixed;
    inset: 0;
    z-index: 1000;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
  }

  :global(.modal-content) {
    background: #0d1020;
    border: 1px solid var(--text-ghost);
    border-radius: 8px;
    padding: 2rem;
    max-width: 420px;
    width: 100%;
  }

  :global(.modal-title) {
    font-family: var(--font-sans);
    font-size: 0.7rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--text-primary);
    margin-bottom: 1rem;
  }

  :global(.modal-content p) {
    font-family: var(--font-sans);
    font-size: 0.8rem;
    color: var(--text-muted);
    line-height: 1.5;
    margin-bottom: 0.75rem;
  }

  :global(.modal-content input[type="text"]),
  :global(.modal-content input[type="password"]) {
    width: 100%;
    background: transparent;
    border: 1px solid var(--text-ghost);
    color: var(--text-primary);
    font-family: var(--font-mono);
    font-size: 0.8rem;
    padding: 0.55rem 0.75rem;
    margin-bottom: 0.5rem;
    box-sizing: border-box;
  }

  :global(.modal-content input:focus) {
    outline: none;
    border-color: var(--accent);
  }

  :global(.modal-error) {
    font-family: var(--font-sans);
    font-size: 0.72rem;
    color: #cc4444;
    min-height: 1.2em;
    margin-bottom: 0.5rem;
  }

  :global(.modal-password-row) {
    margin-bottom: 0.5rem;
  }

  :global(.modal-actions) {
    display: flex;
    gap: 0.6rem;
    justify-content: flex-end;
    margin-top: 0.75rem;
  }

  :global(.danger-button) {
    border-color: #a05050;
    color: #cc4444;
  }

  :global(.danger-button:hover:not(:disabled)) {
    border-color: #cc4444;
    color: #ff5555;
    background: rgba(204, 68, 68, 0.08);
  }

  :global(.danger-button:disabled) {
    opacity: 0.35;
    cursor: not-allowed;
  }

  /* --- Dignity badges --- */
  .chart-content :global(.chart-dignity) {
    font-size: 0.6rem;
    margin-left: 0.15rem;
    vertical-align: super;
    cursor: help;
  }

  .chart-content :global(.chart-dignity-domicile) {
    color: #50a868;
  }

  .chart-content :global(.chart-dignity-exaltation) {
    color: #d6af72;
  }

  .chart-content :global(.chart-dignity-detriment) {
    color: #c07050;
  }

  .chart-content :global(.chart-dignity-fall) {
    color: #a05050;
  }

  /* --- House Cusps --- */
  .chart-content :global(.chart-cusps-section) {
    display: flex;
    flex-direction: column;
    gap: 0.3rem;
    padding-top: 0.5rem;
    border-top: 1px solid var(--text-ghost);
  }

  .chart-content :global(.chart-cusps-grid) {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0.2rem 1rem;
  }

  .chart-content :global(.chart-cusp-row) {
    display: flex;
    align-items: baseline;
    gap: 0.4rem;
    font-family: var(--font-sans);
    font-size: 0.65rem;
    cursor: default;
  }

  .chart-content :global(.chart-cusp-num) {
    color: var(--text-muted);
    font-family: var(--font-mono);
    font-size: 0.55rem;
    width: 1.8rem;
    flex-shrink: 0;
  }

  .chart-content :global(.chart-cusp-deg) {
    font-family: "Segoe UI Symbol", var(--font-body);
    font-size: 0.62rem;
    white-space: nowrap;
  }

  /* --- Aspect Matrix --- */
  .chart-content :global(.chart-matrix-section) {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.3rem;
    padding-top: 0.5rem;
    border-top: 1px solid var(--text-ghost);
    overflow-x: auto;
  }

  .chart-content :global(.chart-matrix) {
    display: inline-flex;
    flex-direction: column;
    gap: 1px;
    font-family: "Segoe UI Symbol", var(--font-sans);
    font-size: 0.62rem;
  }

  .chart-content :global(.matrix-row) {
    display: flex;
    gap: 1px;
  }

  .chart-content :global(.matrix-hdr) {
    width: 1.6rem;
    height: 1.6rem;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    font-size: 0.7rem;
    flex-shrink: 0;
  }

  .chart-content :global(.matrix-cell) {
    width: 1.6rem;
    height: 1.6rem;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.015);
    font-size: 0.7rem;
    flex-shrink: 0;
    cursor: default;
    border-radius: 2px;
  }

  .chart-content :global(.matrix-cell:hover) {
    background: rgba(255, 255, 255, 0.06);
  }

  .chart-content :global(.matrix-diag) {
    background: rgba(214, 175, 114, 0.04);
  }

  .chart-content :global(.matrix-header-row .matrix-hdr) {
    font-size: 0.6rem;
    color: var(--accent);
  }

  /* --- Transit Overlay --- */
  .transit-overlay {
    margin-top: 1.5rem;
    padding-top: 1rem;
    border-top: 1px solid var(--text-ghost);
  }

  /* --- Loading Skeleton --- */
  .chart-skeleton {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    padding: 1rem 0;
  }

  .skeleton-wheel {
    width: 200px;
    height: 200px;
    border-radius: 50%;
    background: linear-gradient(110deg, rgba(255,255,255,0.02) 30%, rgba(255,255,255,0.06) 50%, rgba(255,255,255,0.02) 70%);
    background-size: 200% 100%;
    animation: shimmer 1.5s ease-in-out infinite;
  }

  .skeleton-lines {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    width: 100%;
    max-width: 300px;
  }

  .skeleton-line {
    height: 10px;
    border-radius: 4px;
    background: linear-gradient(110deg, rgba(255,255,255,0.02) 30%, rgba(255,255,255,0.06) 50%, rgba(255,255,255,0.02) 70%);
    background-size: 200% 100%;
    animation: shimmer 1.5s ease-in-out infinite;
  }

  .skeleton-line.short {
    width: 60%;
  }

  @keyframes shimmer {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }

  /* --- Fade-in animation --- */
  .chart-content :global(.chart-fadein) {
    animation: fadeSlideIn 0.5s ease both;
  }

  @keyframes fadeSlideIn {
    from {
      opacity: 0;
      transform: translateY(8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* --- Canvas fade-in --- */
  .chart-wheel-wrap canvas {
    animation: fadeSlideIn 0.4s ease both;
  }

  @media (max-width: 768px) {
    .dashboard-container {
      margin: 0.5rem auto;
      padding: 0 1rem;
    }

    .dashboard-header {
      gap: 0.3rem;
    }

    .section-label {
      margin-top: 0.8rem;
      margin-bottom: 0.3rem;
    }

    .reading-content :global(.loading),
    .reading-content :global(.muted) {
      padding: 1rem;
    }

    .reading-content :global(.reading-meta) {
      margin-bottom: 0.75rem;
    }

    .reading-content :global(.section-heading) {
      margin-top: 0.8rem;
    }

    .logout-wrapper {
      margin: 1.5rem 0 2rem;
    }

    .chart-content :global(.chart-hero) {
      gap: 1rem;
      padding: 0.75rem 0;
    }

    .chart-content :global(.chart-hero-glyph) {
      font-size: 1.1rem;
    }

    .chart-content :global(.chart-placements) {
      grid-template-columns: 1fr;
      gap: 0.1rem;
    }

    .chart-content :global(.chart-aspects) {
      grid-template-columns: 1fr;
      gap: 0.1rem;
    }

    .chart-content :global(.chart-details-grid) {
      grid-template-columns: 1fr;
      gap: 0.8rem;
    }

    .chart-content :global(.chart-details-highlights) {
      grid-template-columns: 1fr;
      gap: 0.4rem;
    }

    .chart-content :global(.chart-highlight-card) {
      flex-direction: row;
      justify-content: space-between;
      padding: 0.5rem 0.6rem;
    }

    .chart-content :global(.chart-cusps-grid) {
      grid-template-columns: repeat(3, 1fr);
      gap: 0.15rem 0.6rem;
    }

    .chart-content :global(.chart-matrix-section) {
      margin-left: -0.5rem;
      margin-right: -0.5rem;
    }

    .chart-content :global(.matrix-hdr),
    .chart-content :global(.matrix-cell) {
      width: 1.3rem;
      height: 1.3rem;
      font-size: 0.55rem;
    }
  }
</style>
